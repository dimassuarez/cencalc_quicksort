! This is modified version of the CENCAL code.
! The original version can be found at. 
!
! https://github.com/ernestosuarez/CENCALC
!
!===================================================================
!       CONFORMATIONAL ENTROPY CALCULATION
!      
! Copyright (C) 2011 Ernesto Suarez Alvarez
!
!   This program is free software: you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation, either version 3 of the License, or
!   (at your option) any later version.
!
!   This program is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   http://www.gnu.org/licenses/>.
!-----------------------------------------------------------------------------------------
!  Changes of the original code written by Dimas Suarez (dimas@uniovi.es)  2022
!-----------------------------------------------------------------------------------------
!  Any use of the CENCALC software or derivative should include at least the following 
!  citation:
!
!  1)E. Suarez, N. Diaz, J. Mendez and D. Suarez. CENCALC: A Computational Tool for 
!    Conformational Entropy Calculations from Molecular Dynamics Simulations. 
!    J Comput Chem.  2013 ;34(23):2041-54. doi: 10.1002/jcc.23350.
!
!  The methods implemented in CENCALC are fully described in the following references: 
!
!  2)E. Suarez, N. Diaz and D. Suarez. Entropy Calculations of Single Molecules by 
!    Combining the Rigidï€­Rotor and Harmonic-Oscillator Approximations with Conformational 
!    Entropy Estimations from Molecular Dynamics Simulations 
!    J. Chem. Theor. Comput. 2011 , 7, 8, 2638-2653 doi: 10.1021/ct200216n
!
!  3)E. Suarez, D. Suarez. Multibody Local Approximation: Application in the Conformational 
!    Entropy Calculation on Biomolecules.  
!    J. Chem. Phys. 137, 084115 (2012);  doi: 10.1063/1.4748104
!
!-----------------------------------------------------------------------------------------
!     _____________________________
!    /|                           |
!    /|       MAIN PROGRAM        |
!    /|___________________________|
!    //////////////////////////////


!*****************************************************************************************     
      PROGRAM CENCALC_CCMLA
!*****************************************************************************************
!
! This program computes the conformational entropy from the files generated by the program
! centro_prep: "MATRIX.dat" and "reduced_dist_matrix.dat"(if a cutoff criterion is applied).
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! QUICK HELP:
!
! A quick help can be viewed from the command line by typing: 
! >> cencalc_ccmla -help 
!-----------------------------------------------------------------------------------------
      use parameters
      IMPLICIT NONE
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of Columns(Dihedrals) in MATRIX.dat
      integer NumSelected                                     !Number of Columns(Dihedrals) Selected in MATRIX.dat
      integer NumSnapIni                                      !Initial number of Snapshots
      integer NumSnapTot                                      !Total number of rows(Snapshots) to be considered 
      integer NumSnap                                         !Number of Snapshots used on each CALC 
      integer SnapInterval                                    !Gap in snapshots between consecutive calculations (CALCs)
      integer NumInterval                                       !Number of Snapshot Interval
      integer MaxOrder                                        !Maximum order of expansion (MIE, AMIE, ...)
      integer,dimension (:,:),allocatable :: N(:,:)    !Data Matrix (by default, the content of MATRIX.dat)
      integer,dimension (:,:),allocatable :: tmpN(:,:) !  Auxiliary array for rellocating N if required

      integer Method                                          !Method, the are 3 possible values for this variable:
                                                              ! 1 - MIE  not  available
                                                              ! 2 - AMIE  not  available
                                                              ! 3 - MLA or CCMLA (Correlation Corrected MLA)
                                                              !The discrimination between the two options in 3
                                                              !is done through the "FilterCorrelation" variable
                                                              ! 4 - S1
                                                              ! 5 - S1
                                                                        
      logical FilterCorrelation                               !Filter false correlation? (True/False)
                                                              !(Transforms MLA into CC-MLA)


      integer,dimension (:),allocatable :: X(:)               !Vector whose elements indicate the ordering
                                                              !of the columns in MATRIX.dat that would minimize
                                                              !the additional terms

      integer,dimension (:),allocatable :: invX(:)            !Inverse of X (i.e., invX(X(i))=i for every i)

      integer,dimension (:),allocatable :: idcol(:)           
                                                              
      integer,dimension (:,:),allocatable :: NeigList(:,:)    !Neighbors List. The i-row of this matrix contains
                                                              !the list Li={Ai,...} (see the main references of
                                                              !of the program)

      integer,dimension (:),allocatable :: NumNeig(:)         !Number of Neighbors of the i-element
      real(DP),dimension (:),allocatable :: ENTROPY(:)        !Entropy vs order: Entropy(Order) (MIE,AMIE)
      integer j,i,A,i1,C,k                                    !Counters
      integer MaxNumNeig                                      !Maximum number of neighbors observed
      real(DP),dimension (:),allocatable :: ENT_III(:)        !MLA and/or CC-MLA Entropy
      real(DP) CutOff                                         !Cutoff
      real(DP) MaxDist                                        !Maximum value in the distance matrix
      real(DP) dummy                                          !Dummy real variable
      integer idummy,ios                                      !Dummy integer variables

      logical Reorder                                         !Change the ordering of the dihedrals
                                                              !in order to minimize the additional terms?
                                                              !(True/False)
      logical   lessthan                                      ! Criteria to apply distance cutoff
      real(DP), dimension (:,:),allocatable :: DistIni(:,:)   !Reduced distance matrix before reordering 
      real(DP), dimension (:,:),allocatable :: DIST(:,:)      !Reduced distance matrix after reordering
      real(DP), dimension (:),allocatable ::   S1(:)          !Marginal entropies
      real(DP), dimension (:,:),allocatable :: S2(:,:)        !Second-order entropies

      logical MakeCorrection                                  !Eliminate de additional terms up to de given
                                                              !MaxOrder? (True/False)              

      logical GivenNumCol                                     !Is the number of columns (NumCol) specified? (True/False)
      logical GivenNumSnap                                    !Is the number of snapshots specified? (True/False)
      logical GivenCutoff                                     !Is the cutoff specified? (True/False)
      logical UseCol                                          !Are columns selected ? (True/False) 
      logical S1Calc                                          !Do just first-order calc.
      logical S2Calc                                          !Use MIE Second-Order method ?  (True/False)
      logical verbose                                       !Print statistical data about CCMLA states? (True/False)
      integer Framestep                                       !Row step for reading MATRIX.dat. Default = 1 (i.e. all rows)
      character*1024 TextCol                                   !Text variable for selected columns
      integer,dimension (:),allocatable :: selected(:)        !Pointer to selected columns (dihedrals) in input data file 

      character*12  fmtDIST, fmtDAT                           ! Data Format 

      character*60  filedist                                  !Filename of the distance matrix file 
                                                              !Default:reduced_dist_matrix.dat

      character*60  filedat                                   !Filename of the data file (Default: MATRIX.dat).
                                                              !This file contains the discretized evolution
                                                              !of the dihedral angles 

      character*60  filetable                                 !Filename of the file where the results are
                                                              !summarized in table form

      character*1024 arg                                       !Dummy character variable
      character*8 Estimator                                   !Estimator: Max-Likelihood(-ml) or Chao-Shen(-cs)
      integer CALC                                            !Counter for the number of calculations
      real CpuTime1,CpuTime2,CpuTimeTot                       !CPU time variables
      integer(K4C) RTime1,RTime2,RT1,RT2,rate                 !Auxiliary variables to compute real-time
      real T_Temp                                             !Temporal variable where is saved real-time estimations
      real(DP),dimension (:),allocatable :: CORRECTION(:)     !Entropy Correction to eliminate the additional terms

      integer(K4B) idum                                       !Auxiliary variable for the random number generator
                                                              !in function "ran"
      integer ii,jj                                           ! Some Auxiliary variables
      integer NumProcs, NumThreads, OMP_get_num_procs, OMP_get_num_threads

      character*1024 cdummy
      real(DP), dimension (:),allocatable ::   rdummy(:)          
      logical LA,LB
      !-----------------------------------------------------------------------------------


      write(*,'(A33)') " _______________________________ "
      write(*,'(A33)') "||  _____                       |"
      write(*,'(A33)') "||  \\   ||                     |"
      write(*,'(A33)') "||   \\  PROGRAM CENCALC_CCMLA  |"
      write(*,'(A33)') "||   //     using quicksort     |"
      write(*,'(A33)') "||  //___||                     |"
      write(*,'(A33)') "||______________________________|"
      print*," "


      call system_clock(count=RTime1, count_rate=rate)


!---DEFAULT/INITIAL VALUES----------------------------------------------------------------
      idum=-1                                                 !Initialize idum for random       
                                                              !number generator in function ran
      filedat='MATRIX.dat'                                    
      filedist='reduced_dist_matrix.dat'                      
      filetable='TABLE.out'                                   
      CutOff=8.0d0                                                
      MaxOrder=4                                                
      MaxDist=0.d0
      UseCol=.false.
      GivenNumCol=.false.                                                   
      GivenNumSnap=.false.                                            
      GivenCutoff=.false.                                                   
      SnapInterval=1000                                               
      Method=3                                                  
      Reorder=.true.                                            
      MakeCorrection=.false.                                
      FilterCorrelation=.true.                               
      s1calc=.false.
      s2calc=.false.
      verbose=.false.
      lessthan=.true. 
      Estimator="ml"                                          
      Framestep=1
      fmtDIST='(F9.3)'
      fmtDAT='(I2)'
!------OMP info----------------------------------------------------------------------------------
      NumProcs = 1
      NumThreads = 1
!$omp parallel 
!$    NumProcs = OMP_get_num_procs()
!$    NumThreads = OMP_get_num_threads()
!$omp end parallel 

! Number of Threads cannot be greater than NumProcs since
! we request paralell IO of data files 
!$    print*,'OMP Parallel Execution'
!$    print*,"Number of Processors=",NumProcs
!$    print*,"Number of Threads   =",NumThreads
!$    if ( NumThreads > NumProcs ) then
!$         call OMP_set_num_threads(NumProcs)
!$         print*,'Number of Threads set to ',NumProcs
!$    endif

     
!---READING OPTIONS-----------------------------------------------------------------------
      CALL Read_Options(CutOff,MaxOrder,Method,filedat,filedist,filetable,fmtDAT,fmtDIST  &
      ,NumSnap,NumSnapIni,NumCol,SnapInterval,GivenNumCol,GivenNumSnap,GivenCutoff,verbose &
      ,Reorder,Estimator,MakeCorrection,FilterCorrelation,UseCol,TextCol,Lessthan,Framestep)
!-----------------------------------------------------------------------------------------
!---READING THE REDUCED-DISTANCE-MATRIX IF THE CUTOFF IS GREATER OR EQUAL ZERO------------
      if(CutOff.ge.0.0d0) then
      write(*,'(A30)')"Reading the distance matrix..."
      write(*,*)"filename: ",filedist
      MaxDist=0d0

      open(3,file=filedist,status='old',iostat=ios)           !Opening the distance matrix file
      if(ios.ne.0) then
       print*,"Error during opening of ",filedist
       stop
      endif

      if(.not.GivenNumCol) then    !If NumCol is not specified, 
              C=0                  !count how many columns there are
              ios=0
              do while(ios==0)
               read(3,fmtDIST,iostat=ios,advance='no') dummy !Just to know the number of columns
               if(ios>0) then
                print*,"Error(2) while reading (using format ",fmtDIST," ) ",filedist
                stop
               endif
               if(ios<0) exit
               C=C+1
              enddo
              rewind(3)
           
              A=0
              ios=0
              do while(ios==0)
                read(3,*,iostat=ios) dummy                    !Just to know the number of rows
                if(ios>0) stop "Error(3) while reading reduced_dist_matrix.dat"
                if(ios==-1) exit
                A=A+1
              enddo
              rewind(3)
           
              if(A.eq.C) then
                  NumCol=C
                  write(*,'(A26,I6)')   "Number of columns and rows:",NumCol
              else
                  Stop "Error(4) The number of columns and rows are not the same"
              endif
      endif

      allocate(DistIni(NumCol,NumCol))  
      allocate(DIST(NumCol,NumCol))  
      allocate(X(NumCol))  
      allocate(invX(NumCol))  
      allocate(selected(NumCol))
      allocate(idcol(NumCol))
!
!     If we use specific columns then selected(i)=0/1 for dihedral i
!     discarded/selected. X is used here as temporary array
!
      if (UseCol )  then
          cdummy=TextCol
          call Select_Columns(NumCol,cdummy,selected)
          NumSelected=0
          do i=1,NumCol
            if ( selected(i) .eq. 1) then 
               NumSelected=NumSelected+1
               X(NumSelected)=i
            endif
          enddo 
          do i=1,NumSelected
            selected(i)=X(i)
            idcol(i)=selected(i)
            X(i)=0
          enddo
!
      else  
           NumSelected=NumCol
           do i=1,NumSelected
              selected(i)=i
              idcol(i)=selected(i)
           enddo
      endif
!
      do i=1,NumCol
        read(3,'(10000'//fmtDIST//')',iostat=ios)(DistIni(i,j),j=1,NumCol)
        do j=1,NumCol
           DistIni(i,j)=abs(DistIni(i,j))
        enddo
        if(ios>0) then 
           print*,"Error(1) while reading ",filedist
           stop
        elseif(ios<0) then
           print*,"Error(1) Unexpected end of file or record"
           stop
        endif
      enddo
!
!      If UseCol then we prune the DistIni matrix in terms of the 
!      reduced number of columns. DIST is used here as a temporary
!      array. 
!
      if ( UseCol) then 
         do ii=1,NumSelected
           i=selected(ii)
           do jj=1,NumSelected
              j=selected(jj)
              DIST(ii,jj)=DistIni(i,j)
           enddo
         enddo
         do ii=1,NumSelected
         do jj=1,NumSelected
              DistIni(ii,jj)=DIST(ii,jj)
         enddo
         enddo
      endif
!
      do i=1,NumSelected
       X(i)=i                                                 !Initial values for X
       invX(i)=i                                              !and invX
      enddo

      if(Reorder) then      !Getting the  actual values for X and invX
        ! X:    Reordered array of selected torsions to minimize additional
        !       terms. Since X elements are themselves indexes, X i used
        !       to reorder the DIST elements
        ! 
        ! invX: Index array keeping track of original and final ordering 
        !       invX(1)=4  ----> First torsion (1) becomes fourth (4)
        !
        CALL Get_Best_Ordering(DistIni(1:NumSelected,1:NumSelected),NumSelected,CutOff,lessthan,X,invX)  

        print*,'==================================='
        print*,'# of columns to be read=',NumSelected,' out of ',NumCol
        print*,' Original_Ordering  Final_ordering'
        print*,'==================================='
        do i=1,NumSelected
               write(*,'(5X,2(I5,15X))') selected(i),invX(i) 
               idcol(invX(i))=selected(i)
        enddo
      endif

      do i=1,NumSelected
        do j=1,NumSelected
         DIST(i,j)=DistIni(X(i),X(j))                         !Reordering the distance matrix
         if(DIST(i,j).gt.MaxDist) MaxDist=DIST(i,j)           !taking into account the vector X
        enddo                                                 !Once that X is used here, it can be 
      enddo                                                   !overwritten for other purposes

      endif  ! READING DIST DATA
!-----------------------------------------------------------------------------------------

!---READING THE DATA MATRIX---------------------------------------------------------------
      write(*,*)" "
      write(*,'(A26)')"Reading the data matrix..."
      write(*,*)"filename: ",filedat
      open(2,file=filedat,status='old',iostat=ios)
      if(ios.ne.0) then
       print*,"Error during opening of ",filedat
       stop
      endif

      if(.not.GivenNumCol) then                               !If NumCol is not specified,
           A=0                                                !count how many columns there are
           ios=0
           do while(ios==0)
            read(2,fmtDAT,iostat=ios,advance='no') idummy     !Just to know the number of columns
             if(ios>0) then
              print*,"Error(5) while reading(using format",fmtDAT,") ",filedat
              stop 
             endif
             if(ios<0) exit
            A=A+1
           enddo
           if((A.ne.NumCol).and.(CutOff.ge.0d0)) stop  &
           "Error(55) The number of columns of the distance matrix and &
            &the data file are not the same"
           NumCol=A
           print'(A18,I6)',"Number of Columns:",NumCol
      endif
      rewind(2)

      if(.not.GivenNumSnap) then                              !If NumSnap is not specified,
           A=0                                                !count how many rows there are
           ios=0                                              !in the data matrix
           do while(ios==0)
            read(2,*,iostat=ios) dummy                        !Just to know the number of snapshots(rows)
            if(ios>0) stop "Error(6) while reading the data file"
            if(ios==-1) exit
            A=A+1
           enddo
           NumSnap=A
           NumSnapIni=A
           print'(A27,I8)',"Number of Snapshots read:",NumSnap
      endif
      rewind(2)

      if (Cutoff .lt. 0.0d0) allocate (X(NumCol))
      if (Cutoff .lt. 0.0d0) allocate (selected(NumCol))
      if (Cutoff .lt. 0.0d0) allocate (idcol(NumCol))
!     
!    If no cutoff is used then UseCol must be processed here
!
      if (( UseCol ) .and. (Cutoff .lt. 0.0d0))  then
          cdummy=TextCol
          call Select_Columns(NumCol,cdummy,selected)
          NumSelected=0
          do i=1,NumCol
            if ( selected(i) .eq. 1) then 
               NumSelected=NumSelected+1
               X(NumSelected)=i
            endif
          enddo 
          do i=1,NumSelected
            selected(i)=X(i)
            idcol(i)=selected(i)
            X(i)=0
          enddo
!
!         print*,'Selected',(selected(i),i=1,NumSelected)
!
      elseif ( .not. UseCol ) then  
           NumSelected=NumCol
           do i=1,NumCol
            selected(i)=i
            idcol(i)=selected(i)
           enddo
      endif
!
!     Read the big matrix
!
      allocate(N(NumSnap,NumSelected)) !----------------------!Once the exact number of columns and rows
                                                              !to be considered in the data matrix are
                                                              !known, then allocate N and save the info on it.
      k=0
      do i=1,NumSnap 
!
!       X is used here as a temporary array
!
        read(2,'(10000'//fmtDAT//')',iostat=ios) (X(j),j=1,NumCol)    

        if(ios>0) then
           print*,"Error(7) while reading ",filedat
           stop
        elseif(ios<0) then
           print*,"Error(7) Unexpected end of ",filedat
           print*,"If you have specified the Num of Snapshots using -ns,"
           print*,"then check that the number of rows in ",filedat     
           print*,"is greater or equal than the specified Num of Snapshots"
           stop
        endif
        
        if ( (i/Framestep)*Framestep .eq. i ) then 

           k=k+1

           if (CutOff.ge.0.0d0) then     !--------Read the data matrix taking into account the optimal
              do jj=1, NumSelected           !ordering given by X, or specifically, given by invX
                N(k,invX(jj))=X( selected(jj) ) 
              enddo
           else            !---------------If cutoff<0 (infinite cutoff) read the data matrix normally  
              do jj=1, NumSelected                                   
                N(k,jj)=X( selected(jj) ) 
              enddo
           endif 
    
    
        endif

      enddo

      if ( Framestep .gt. 1 ) then 
          print*,' framestep=',Framestep
          print*,' Only ',k,' evenly-spaced snapshots are loaded for Entropy calcs'
          NumSnap=k
          print*,' NumSnap reassigned value=',k
          allocate(tmpN(NumSnap,NumSelected)) 
          tmpN=N(1:NumSnap,:)
          call move_alloc(tmpN, N)
      endif 
!
      NumCol=NumSelected
!-----------------------------------------------------------------------------------------

!---CALCULATING THE ENTROPY---------------------------------------------------------------

      write(*,*) " "
      write(*,'(A25)') "-------------------------"
      write(*,'(A25)') " CALCULATING THE ENTROPY "
      write(*,'(A25)') "-------------------------"
      print*, " "

      if((MaxOrder.gt.NumCol).and.((Method.eq.1).or.(Method.eq.2))) then
        print*,"WARNING: Order is greater than the number of Columns"
        print*,"         NumColumns will be taken as MaxOrder"
        MaxOrder=NumCol
      endif
      if ( UseCol ) then 
        print*,"WARNING: Using only data from columns ",TextCol
      endif


      open(1,file=filetable,status='replace')
 
      MaxNumNeig=NumCol
      allocate(NumNeig(NumCol))
      allocate(NeigList(NumCol,MaxNumNeig))
      if ( cutoff .le. 0.d0 ) then 
        do i=1,NumCol
          k=0
          NumNeig(i)=0
          do j=i+1,NumCol
             k=k+1
             NeigList(i,k)=j
             NumNeig(i)= NumNeig(i)+1
          enddo
       enddo
      else
        if(CutOff.gt.MaxDist) then
           print*,"WARNING: CutOff bigger than MaxDistance in Distance Matrix"
           stop                
        endif
        CALL Get_Neighbors_Info(DIST(1:NumCol,1:NumCol),NumCol,CutOff,Lessthan,NeigList,NumNeig)
      endif 

      NumSnapTot=NumSnap !------------------------------------!Actually, at this point NumSnap is the total
                                                              !number of snapshots considered, that's why 
                                                              !we save its value in NumSnapTot. 


      print'(A25)',  "========================="          !
      if(Estimator.eq."cs") &                             !
         print*, " Estimator: Chao-Shen (requested, but currently not implemented)"        ! 
      if(Estimator.eq."ml") &                             !
         print*, " Estimator: Max-Likelihood"        !       
      S1CALC=(Method.eq.4) 
      S2CALC=(Method.eq.5) 
      if(S1Calc) then
      print'(A17,A8)',  "Method:          ","S1=MIE 1st-order"  !
      elseif(S2Calc) then
      print'(A17,A8)',  "Method:          ","S2=MIE 2nd-order"  !
      else
      print'(A17,A8)',  "Method:          ","CC-MLA"      !
      endif
      if ( ( lessthan ) .and. (CutOff.gt. 0.d0) )  then 
      print'(A25,F8.3)'," Distance < Cut-Off = ",CutOff   !
      else if ( CutOff .gt. 0d0 ) then 
      print'(A25,F8.3)'," Distance > Cut-Off = ",CutOff   !
      else
      print'(A17,F8.3)',"Cut-Off:         ",CutOff        !
      endif
      print'(A17,I8)',  "Num of Snapshots:",NumSnap       !
      print'(A17,I8)',  "Num of Columns  :",NumCol        ! 
      print'(A25)',  "========================="          !
 

      NumInterval=int( ( NumSnapTot-NumSnapIni )/SnapInterval) + 1      
      allocate(ENT_III(NumInterval))

      call random_seed()
      call cpu_time(CpuTime1)
      call system_clock(count=RT1)
!
      if (  ( S2CALC ) .or. ( S1CALC ) )  then

      allocate(S1(NumCol))
      allocate(S2(NumCol,NumCol))

      CALL S1_S2_calc(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumCol,NeigList,   &
      NumNeig,MaxNumNeig,ENT_III,S1,S2,CutOff,Estimator,s1calc)

      else

      CALL CCMLA_calc(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumCol,NeigList,   &
      NumNeig,MaxNumNeig,ENT_III,CutOff,Estimator,verbose,idcol(1:NumCol),idum)

      endif 
      !------------------------------------------------------------------

      !----------------------------------------------------!Write Results
      write(*,*) " "
      write(*,'(A43)') "ESTIMATED ENTROPY (cal/mol-Kelvin)         "
      write(*,'(A43)') "-----------------------------------        "
      write(*,'(A9,A12)') "# NumSnap","Entropy"
      write(*,'(I9,50F12.4)') NumSnap, ENT_III
      print'(A4)',"DONE"
      k=0
      write(1,'(A9,A12)') "# NumSnap", "Entropy"
      do NumSnap=NumSnapIni,NumSnapTot,SnapInterval
          k=k+1
          write(1,'(I9,50F12.4)') NumSnap, ENT_III(k)
      enddo
      call cpu_time(CpuTime2)
      call system_clock(count=RT2)
      T_Temp=real(RT2-RT1)/rate
      write(*,'(A26,I3,A1,F11.2,A8,F9.2,A6)')" Partial cpu-time for CALC",&
           CALC,":",CpuTime2-CpuTime1," seconds",((CpuTime2-CpuTime1)/3600.)," hours"
      write(*,'(A26,I3,A1,F11.2,A8,F9.2,A6)')"Partial real-time for CALC",&
           CALC,":",T_Temp," seconds",(T_Temp/3600.)," hours"
      print*," "


      if ( S2CALC ) then
         write(1,'(''================================'')')
         write(1,'('' Array of First Order Entropies'')')
         write(1,'(''================================'')')
         do i=1,NumCol
            write(1,'(I4,F12.8)') idcol(i),S1(i)
         enddo
         write(1,'(''==================================='')')
         write(1,'('' Matrix of Second Order Corrections'')')
         write(1,'(''==================================='')')
         write(1,'('' 0 '',4X,10000(I4))') (idcol(j),j=1,NumCol)
         do i=1,NumCol
            write(1,'(I4,1X,10000(F12.8))') idcol(i),(S2(i,j),j=1,NumCol)
         enddo
      endif

      close(1)
      close(2)
      close(3)


      !-------------------------------------------------------!Write the computational cost
      call cpu_time(CpuTimeTot)
      call system_clock(count=RTime2)
      T_Temp=real(RTime2-RTime1)/rate
      write(*,'(A30,F11.2,A8,F9.2,A6)')"TOTAL CPU-TIME :",&
           CpuTimeTot," seconds",(CpuTimeTot/3600.)," hours"
      write(*,'(A30,F11.2,A8,F9.2,A6)')"TOTAL REAL-TIME:",&
           T_Temp," seconds",(T_Temp/3600.),"hours"

      STOP                                                    !----------FINISH-----------
!-----------------------------------------------------------------------------------------
      END PROGRAM CENCALC_CCMLA
!-----------------------------------------------------------------------------------------
!      _____________________________
!     /|                           |
!     /| SUBROUTINES AND FUNCTIONS |
!     /|___________________________|
!     //////////////////////////////

!*****************************************************************************************
      SUBROUTINE S1_S2_calc(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot     &
      ,NumCol,NeigList,NumNeig,MaxNumNeig&
      ,Entropy,S1,S2,CutOff,Estimator,s1calc)
!
!*****************************************************************************************
!As the name implies, this subroutine computes the MIE second-order entropy 
!using the given cutoff
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnapIni                                      !Initial number of snapshots
      integer SnapInterval                                    !Snapshot interval
      integer NumInterval                                     !Number of Snap interval
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxNumNeig                                      !Max number of neighbors observed
      integer,intent(in out)::N(NumSnapTot,NumCol)            !Data Matrix
      logical s1calc

      integer NeigList(NumCol,MaxNumNeig)                     !Neighbors Lists. The i-row contains
                                                              !the list Li={Ai,...} (see ref.(3))
      integer XAB(2)

      integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumState                                        !
      real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values    
      real(DP),intent(out)::S1(NumCol)                        ! Array of Entropy Values    
      real(DP),intent(out)::S2(NumCol,NumCol)                 ! Array of Entropy Values    
      integer i,j                                             !Counters
      real(DP) CutOff                                         !CutOff

      integer,dimension (:),allocatable :: CountState
      real(DP),dimension (:),allocatable :: ENT1_2            
      real(DP),dimension (:,:),allocatable :: ENT1            
      real(DP),dimension (:,:),allocatable :: ENT2            

      integer iprevious,Limit,ii,idmax                        !Auxiliary integer variables
      character*8 Estimator                                   !Estimator

      !-----------------------------------------------------------------------------------

      !Initial values
      Entropy=0d0
      iprevious=0
!
!     Checking maximum ID 
!
      idmax=0
      do i=1,NumSnapTot
        do j=1,NumCol
           N(i,j)=N(i,j)-1       !  For coding N rows into a big integer number
        enddo
        if (maxval(N(i,:)) .gt. idmax) idmax=maxval(N(i,:))
      enddo
!
      !-Allocating
      allocate(ENT1(NumCol,NumInterval))
      allocate(ENT2(NumCol,NumInterval))
      allocate(ENT1_2(NumInterval))
      allocate(CountState(NumSnapTot))

      S1=0.0d0
      S2=0.0d0
      do i=1,NumCol 
        ENT1(i,:)=0.0d0
        ENT2(i,:)=0.0d0
      enddo
      
      !-Computing the marginal entropies
      do j=1,NumCol
        CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,j),   &
        NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1(j,:),NumState,CountState) 
        S1(j)=ENT1(j,NumInterval)
      enddo

      if ( s1calc ) then 
        do i=1,NumCol
          Entropy=Entropy+ENT1(i,:) 
        enddo
        deallocate(ENT1)
        deallocate(ENT2)
        deallocate(ENT1_2)
        deallocate(CountState)
        return
      endif

      write(*,*) "          ..."

      do i=1,NumCol
           XAB(1)=i
           do j=1,NumNeig(i)
              XAB(2)=NeigList(i,j)
              ENT1_2=0.d0
           !--------------------------------------------------! S2_AB
              CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,XAB(1:2)),   &
              NumSnapIni,SnapInterval,NumInterval,NumSnapTot,2,ENT1_2,NumState,CountState) 
              ENT2(i,:)=ENT2(i,:) + ENT1_2 - ENT1(i,:) - ENT1(XAB(2),:) 
              S2(XAB(1),XAB(2))=ENT1_2(NumInterval)-S1(XAB(1))-S1(XAB(2))
              S2(XAB(2),XAB(1))=S2(XAB(1),XAB(2))
           enddo   
           if((10*i/NumCol).gt.iprevious) then
             write(*,*) 10*(iprevious+1),"%"
             iprevious=10*i/NumCol
           endif
      enddo

      do i=1,NumCol
       Entropy=Entropy+ENT1(i,:) + ENT2(i,:)
      enddo

      deallocate(ENT1)
      deallocate(ENT2)
      deallocate(ENT1_2)
      deallocate(CountState)
      return
      END SUBROUTINE S1_S2_calc   
!-----------------------------------------------------------------------------------------


!*****************************************************************************************
      SUBROUTINE CCMLA_calc(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot     &
      ,NumCol,NeigList,NumNeig,MaxNumNeig&
      ,Entropy,CutOff,Estimator,verbose,idcol,idum)
!*****************************************************************************************
!As the name implies, this subroutine computes the CCMLA entropy 
!using the given cutoff
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnapIni                                      !Initial number of snapshots
      integer SnapInterval                                    !Snapshot interval
      integer NumInterval                                     !Number of Snap interval
      integer NumSnapTot                                      !Total number of snapshots considered
      integer MaxNumNeig                                      !Max number of neighbors observed
      integer,intent(in out)::N(NumSnapTot,NumCol)            !Data Matrix
      integer,intent(in )::idcol(NumCol)           

      integer,dimension (:,:),allocatable :: NewN(:,:) !The data matrix after random reordering
                                                              !of the elements of its columns.

      integer NeigList(NumCol,MaxNumNeig)                     !Neighbors Lists. The i-row contains
                                                              !the list Li={Ai,...} (see ref.(3))

      integer X(NumCol)                                       !Temporal variable where is saved when needed
                                                              !one of the lists Li={Ai,...} (see ref.(3)

      integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
      integer NumSnap                                         !Number of snapshots in the current CALC
      logical verbose                                       ! Print out ccmla data ?
      real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values    
      integer i,j,k,l,kmax                                             !Counters
      real(DP) CutOff                                         !CutOff

      integer,dimension (:),allocatable ::  CountState
      integer NumState_A, NumState_B                                      
      real(DP) cmean_A,cvar_A, csd_A, fmax , sterm , pterm, sapprox, fhist
      real(DP) cmean_B,cvar_B, csd_B
      integer  cmax_A,cmin_A,c
      integer  cmax_B,cmin_B
      integer,dimension (:),allocatable ::  freq_A
      integer,dimension (:),allocatable ::  freq_B   

      integer NumState_A_rand, NumState_B_rand                                      
      real(DP) cmean_A_rand,cvar_A_rand, csd_A_rand  
      real(DP) cmean_B_rand,cvar_B_rand, csd_B_rand
      integer  cmax_A_rand,cmin_A_rand
      integer  cmax_B_rand,cmin_B_rand
      integer,dimension (:),allocatable ::  freq_A_rand
      integer,dimension (:),allocatable ::  freq_B_rand   

      real(DP),dimension (:),allocatable :: ENT1_1            !S(Li) see ref(3) for notations
      real(DP),dimension (:),allocatable :: ENT1_2            !S'(Li) see ref(3) for notations
      real(DP),dimension (:),allocatable :: ENT2_1            !S(Li-Ai) see ref(3) for notations
      real(DP),dimension (:),allocatable :: ENT2_2            !S'(Li-Ai) see ref(3) for notations
      real(DP),dimension (:,:),allocatable :: ENT1            !ENT1(i)=S(Li)-S'(Li) 
      real(DP),dimension (:,:),allocatable :: ENT2            !ENT2(i)=S(Li-Ai)-S'(Li-Ai)

      integer,dimension (:),allocatable :: RandRow(:)         !A vector where the components are selected
                                                              !randomly without replacement from {1,...,NumSnap}  

      real(DP),dimension (:,:),allocatable :: S1              !Matrix of marginal entropies 
      integer iprevious,Limit,ii,idmax                        !Auxiliary integer variables
      character*8 Estimator                                   !Estimator
      logical founded                                         !Auxiliary logical variables

      integer(K4B), intent(in out) :: idum                    !Auxiliary variable for the random number generator
                                                              !in function "ran"
      !-----------------------------------------------------------------------------------

      !Initial values
      Entropy=0d0
      iprevious=0
      founded=.false.
      fhist=25.0d0
      if ( verbose ) then
         write(*,'(''CCMLA verbose output '')')
      else
         write(*,'(''CCMLA normal output '')')
      endif
!
!     Checking maximum ID 
!
      idmax=0
      do i=1,NumSnapTot
        do j=1,NumCol
           N(i,j)=N(i,j)-1       !  For coding N rows into a big integer number
        enddo
        if (maxval(N(i,:)) .gt. idmax) idmax=maxval(N(i,:))
      enddo
!
      !-Allocating
      allocate(ENT1(NumCol,NumInterval))
      allocate(ENT2(NumCol,NumInterval))
      allocate(ENT1_1(NumInterval))
      allocate(ENT1_2(NumInterval))
      allocate(ENT2_1(NumInterval))
      allocate(ENT2_2(NumInterval))
      allocate(S1(NumCol,NumInterval))
      allocate(RandRow(NumSnapTot))
      allocate(NewN(NumSnapTot,NumCol))
      allocate(CountState(NumSnapTot))

      do i=1,NumSnapTot
        RandRow(i)=i
      enddo

      !-Obtaining NewN
      do j=1,NumCol
       call Randomize_Row(RandRow,NumSnapTot,idum)
       do i=1,NumSnapTot
        NewN(i,j)=N(RandRow(i),j)
       enddo
      enddo

      S1=0.0d0
      do i=1,NumCol 
        ENT1(i,:)=0.0d0
        ENT2(i,:)=0.0d0
        if ((NumNeig(i).eq.(NumCol-i)).and.(.not.founded)) then
         Limit=i
         founded=.true.
        endif
      enddo
      
      !-Computing the marginal entropies
      do j=1,NumCol
        CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,j),   &
        NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,S1(j,:),k,CountState) 
      enddo

      write(*,*) "          ..."

      do i=1,NumCol
           ENT1_1=0.d0
           ENT1_2=0.d0
           ENT2_1=0.d0
           ENT2_2=0.d0
           ENT1(i,:)=0.d0
           ENT2(i,:)=0.d0

           if ( NumNeig(i) .ge. 1 ) then 

           ! Printing List of Neigbohrs
             if ( verbose ) then 
               write(*,'(''COL='',I3,'' Neighbohrs='',512(I4))') i,(NeigList(i,j),j=1,NumNeig(i))
               write(*,'(''IDCOL='',I3,'' Neighbohrs='',512(I4))') idcol(i),(idcol(NeigList(i,j)),j=1,NumNeig(i))
             endif
         
             do j=1,NumNeig(i)
              X(j)=NeigList(i,j)
             enddo
             X(NumNeig(i)+1)=i
             !--------------------------------------------------!Computing S(Li) and S'(Li)
             CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i)+1)),   &
                  NumSnapIni,SnapInterval,NumInterval,NumSnapTot,(NumNeig(i)+1),ENT1_1,NumState_A,CountState) 
                  
             if ( verbose ) then 
             ! Printing Some Statistical Info of the Multivariate Counting 
                  cmean_A=0.0d0
                  do k=1,NumState_A
                     cmean_A=cmean_A+real(CountState(k),kind=DP)
                  enddo
                  cvar_A=0.0d0
                  cmean_A=cmean_A/real(NumState_A,kind=DP)
                  do k=1,NumState_A
                     cvar_A=cvar_A+(real(CountState(k),kind=DP)-cmean_A)**2
                  enddo
                  cvar_A=cvar_A/real(NumState_A,kind=DP)
                  csd_A= sqrt( cvar_A )
                  cmax_A=maxval(CountState(1:NumState_A))
                  cmin_A=minval(CountState(1:NumState_A))
                  write(*,'(''         NumState_A='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
                  NumState_A, cmean_A, csd_A, cmax_A,cmin_A    
                  fmax=fhist*(log10(real(NumSnapTot,kind=DP)))
                  kmax=int(fmax)+1
                  allocate (freq_A(kmax))
                  allocate (freq_B(kmax))
                  allocate (freq_A_rand(kmax))
                  allocate (freq_B_rand(kmax))
                  freq_A=0
                  freq_B=0
                  freq_A_rand=0
                  freq_B_rand=0
                  do k=1,NumState_A
                     c=CountState(k)
                     l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
                     freq_A(l)=freq_A(l)+1
                  enddo
               endif                    

 
           CALL ENTRO_OMP_QSORT(idmax,NewN(1:NumSnapTot,X(1:NumNeig(i)+1)), &
                NumSnapIni,SnapInterval,NumInterval,NumSnapTot,(NumNeig(i)+1),ENT1_2,NumState_A_rand,CountState)
           if ( verbose ) then 
                cmean_A_rand=0.0d0
                do k=1,NumState_A_rand
                   cmean_A_rand=cmean_A_rand+real(CountState(k),kind=DP)
                enddo
                cvar_A_rand=0.0d0
                cmean_A_rand=cmean_A_rand/real(NumState_A_rand,kind=DP)
                do k=1,NumState_A_rand
                   cvar_A_rand=cvar_A_rand+(real(CountState(k),kind=DP)-cmean_A_rand)**2
                enddo
                cvar_A_rand=cvar_A_rand/real(NumState_A_rand,kind=DP)
                csd_A_rand= sqrt( cvar_A_rand )
                cmax_A_rand=maxval(CountState(1:NumState_A_rand))
                cmin_A_rand=minval(CountState(1:NumState_A_rand))
                write(*,'(''         NumState_A_rand='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
                NumState_A_rand, cmean_A_rand, csd_A_rand, cmax_A_rand,cmin_A_rand    
                do k=1,NumState_A_rand
                   c=CountState(k)
                   l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
                   freq_A_rand(l)=freq_A_rand(l)+1
                enddo
           endif


           ENT1(i,:)=ENT1_1-ENT1_2
           if ((i.ne.NumCol).and.(NumNeig(i).ne.0)) then
           !--------------------------------------------------!Computing S(Li-Ai) and S'(Li-Ai)
            CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i))), &
                 NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumNeig(i),ENT2_1,NumState_B,CountState)
           if ( verbose ) then 
           ! Printing Some Statistical Info of the Multivariate Counting 
                cmean_B=0.0d0
                do k=1,NumState_B
                   cmean_B=cmean_B+real(CountState(k),kind=DP)
                enddo
                cvar_B=0.0d0
                cmean_B=cmean_B/real(NumState_B,kind=DP)
                do k=1,NumState_B
                   cvar_B=cvar_B+(real(CountState(k),kind=DP)-cmean_B)**2
                enddo
                cvar_B=cvar_B/real(NumState_B,kind=DP)
                csd_B= sqrt( cvar_B )
                cmax_B=maxval(CountState(1:NumState_B))
                cmin_B=minval(CountState(1:NumState_B))
                write(*,'(''         NumState_B='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
                NumState_B, cmean_B, csd_B, cmax_B,cmin_B    
                freq_B=0
                do k=1,NumState_B
                   c=CountState(k)
                   l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
                   freq_B(l)=freq_B(l)+1
                enddo
            endif

            CALL ENTRO_OMP_QSORT(idmax,NewN(1:NumSnapTot,X(1:NumNeig(i))),&
                 NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumNeig(i),ENT2_2,NumState_B_rand,CountState)

           if ( verbose ) then 
                cmean_B_rand=0.0d0
                do k=1,NumState_B_rand
                   cmean_B_rand=cmean_B_rand+real(CountState(k),kind=DP)
                enddo
                cvar_B_rand=0.0d0
                cmean_B_rand=cmean_B_rand/real(NumState_B_rand,kind=DP)
                do k=1,NumState_B_rand
                   cvar_B_rand=cvar_B_rand+(real(CountState(k),kind=DP)-cmean_B_rand)**2
                enddo
                cvar_B_rand=cvar_B_rand/real(NumState_B_rand,kind=DP)
                csd_B_rand= sqrt( cvar_B_rand )
                cmax_B_rand=maxval(CountState(1:NumState_B_rand))
                cmin_B_rand=minval(CountState(1:NumState_B_rand))
                write(*,'(''         NumState_B_rand='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
                NumState_B_rand, cmean_B_rand, csd_B_rand, cmax_B_rand,cmin_B_rand    
                do k=1,NumState_B_rand
                   c=CountState(k)
                   l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
                   freq_B_rand(l)=freq_B_rand(l)+1
                enddo
             endif

            ENT2(i,:)=ENT2_1-ENT2_2
           else
            ENT2(i,:)=0.d0
           endif

           if ( verbose ) then 
             write(*,'(''         Correlation_Terms_ENT1/ENT2/ENT1-ENT2/Sapprox/='',2F12.4,1X,2F9.4)') &
             ENT1(i,NumInterval),ENT2(i,NumInterval),ENT1(i,NumInterval)-ENT2(i,NumInterval),sapprox
             write(*,'(''         log10(Count)    Count     Freq_A    Freq_B    Freq_A_rand   Freq_B_rand    S_approx '')')  
             sapprox=0.d0
             do  k=1,kmax
               if ( freq_A(k)+freq_B(k)+freq_A_rand(k)+freq_B_rand(k) .gt. 0 ) then 
                  pterm= ( 10.d0**( real(k,kind=DP)/fhist ) ) / real(NumSnapTot,kind=DP)
                  sterm= - real(freq_A(k) - freq_A_rand(k) - (  freq_B(k) - freq_B_rand(k)),kind=DP)*R*pterm*log(pterm)
                  write(*,'(''         '',F10.6,E16.8,4I10,F12.4)') &
                  real(k,kind=DP)/fhist, 10.d0**( real(k,kind=DP)/fhist ), &
                  freq_A(k), freq_B(k) , freq_A_rand(k) , freq_B_rand(k),  sterm 
                  sapprox=sapprox+sterm
               endif
             enddo
             deallocate(freq_A)
             deallocate(freq_B)
             deallocate(freq_A_rand)
             deallocate(freq_B_rand)
        
             endif
           
           endif

           if((10*i/NumCol).gt.iprevious) then
              write(*,*) 10*(iprevious+1),"%"
              iprevious=10*i/NumCol
           endif

      enddo

      do i=1,NumCol
       Entropy=Entropy+S1(i,:)+(ENT1(i,:)-ENT2(i,:))                !Finally, computing the CC-MLA Entropy
      enddo

      deallocate(ENT1)
      deallocate(ENT2)
      deallocate(ENT1_1)
      deallocate(ENT1_2)
      deallocate(ENT2_1)
      deallocate(ENT2_2)
      deallocate(S1)
      deallocate(RandRow)
      deallocate(NewN)
      deallocate(CountState)
      return
      END SUBROUTINE CCMLA_calc
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
      SUBROUTINE ENTRO_OMP_QSORT(idmax,N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,&
                 NumCol,Entropy,NumState,CountState)
!*****************************************************************************************
!  This subroutine computes entropy values. 
!
!  It transforms the N(NumSnapIni,NumCol) matrix describing the evolution of
!  discretized dihedral angles along NumSnapIni MD snapshots into one (or more)
!  one-dimensional arrays of NumSnapini (large) integer numbers. This is
!  done as follows:
!
!  N(i,:) = sequence of integer numbers labelling the conformational states
!  of a dihedral set at a the i-snapshot. The values of these integer
!  numbers are <= idmax (Typically idmax=3)
!
!  N(I,:) defines an base-idmax number which is transformed into an idcode 
!  base-10 integer number by means of dot products. Note that idcode is
!  stored using kind=16 integer mode. If NumCol is larger than
!  code_length then N(i,:) is splitted into smaller segments and
!  several idcode identifiers are generated
!
!  Using a parallel recursive implementation of the quicksort algorithm,
!  the master idcode array is sorted what allows to identify the different conformational 
!  states populated by the NumCol dihedrals along the MD trajectory and 
!  to determine their relative abundances. 
!
!  Entropies are calculated for NumInterval segments of the trajectory.
!  Each interval has  NumSnap=NumSnap+(I-1)*SnapInterval snapshots where
!  I=1,NumInterval
!
!-----------------------------------------------------------------------------------------
      use parameters
      use sort
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns (dihedrals)
      integer NumSnapIni                                      !Initial number of snapshots
      integer SnapInterval                                    !Snapshot interval
      integer NumInterval                                     !Number of Snap interval
      integer NumSnapTot                                      !Total number of snapshots considered
      integer NumSnap                                         !Number of snapshots in the current CALC
      integer NumState                                        !Number of Detected Conformational States 
      integer idmax                                           !Maximum integer value in N
      integer NumSnap0
      integer  N(NumSnapTot,NumCol)                           ! Input Matrix
      real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values    
      integer ,intent(out)::CountState(NumSnapTot)            ! Array of Population data for Conformational States 
      real(DP) p                                              ! Probability (relative frequency)
      integer i,j,k,c,l,ii,idummy                             !  Auxiliary index variables
      integer numid,ifirst,ilast,code_length
      integer,dimension (:),allocatable :: indx               ! Index of 
      integer,dimension (:),allocatable :: iconf              ! Aray collecting the abundances of conformational states
      integer(kind=16) nbase
      integer(kind=16),dimension (:),allocatable :: basepower(:)  
      integer(kind=16),dimension (:,:),allocatable :: idcode(:,:)
      integer(kind=16),dimension (:),allocatable :: idcode_temp(:)
      logical lconf
!
!     Determine the number of ids required for each row in MATRIX
!
      code_length=30
      numid=NumCol/code_length+1
!
!     Precomputing the vector for BASE_nbase ---> BASE_10 conversion
!
      nbase=int(idmax+1,kind=16)  
      allocate(basepower(code_length))
      do i=1,code_length
         basepower(i)=nbase**(int(i-1,kind=16))
      enddo
!
!     Compute the integer ID codes for each row
!
      allocate(idcode(NumSnapTot,numid))
      ifirst=1
      ilast=code_length

      do i=1,numid
        if ( ilast .gt. NumCol ) ilast=NumCol 
        j=ilast-ifirst+1
        !$omp parallel default(none), private(k),& 
        !$omp shared(numsnaptot,idcode,N,basepower,ifirst,ilast,i,j)
        !$omp do schedule(static)
        do k=1,NumSnapTot
            idcode(k,i)=  &
            dot_product(int(N(k,ifirst:ilast),kind=16),basepower(1:j))
        enddo
        !$omp end do
        !$omp end parallel
        ifirst=ilast+1
        ilast=ilast+code_length
!
      enddo 
!
!     Sorting ID codes
!
      allocate (indx(NumSnapTot))
      allocate (idcode_temp(NumSnapTot))
      do i=1,NumSnapTot
         idcode_temp(i)=idcode(i,1)
         indx(i)=i
      enddo
      call MTSort(idcode_temp,indx,NumSnapTot,"Ascending") 
!
!     counting conformational states
!
      allocate (iconf(NumSnapTot))
      iconf(indx(1))=1
      c=1
      do k=2,NumSnapTot
          i=indx(k)  
          j=indx(k-1) 
          lconf=.true.
          do l=1,numid
            lconf=lconf .and.  ( idcode(i,l) .eq. idcode(j,l) )
          enddo
          if ( .not. lconf ) c=c+1
          iconf(i)=c
      enddo
!            
      CountState=0
!
!     computing ML entropy values per interval
!
      NumSnap0=1
      do ii=1,NumInterval
         Entropy(ii)=0.0d0
         NumSnap=NumSnapIni+(ii-1)*SnapInterval
         do i=NumSnap0,NumSnap
             CountState (  iconf(i)  ) =  CountState (  iconf(i)  ) + 1
         enddo
         do k=1,c
           p=real(CountState(k),kind=8)/real(NumSnap,kind=8)
           if ( p .gt. 0.0d0 ) Entropy(ii)=Entropy(ii)-R*p*log(p)
         enddo
         NumSnap0=NumSnap+1
      enddo
!
      NumState=c
!
      deallocate (iconf)
      deallocate (indx)
      deallocate (basepower)
      deallocate (idcode)
      deallocate (idcode_temp)

      return
      END SUBROUTINE ENTRO_OMP_QSORT
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
      SUBROUTINE Get_Best_Ordering(DIST,NumCol,CutOff,lessthan,X,invX)
!*****************************************************************************************
!This subroutine gives through the variable X, the ordering of the torsions that would
!minimize the additional terms.(see ref(3))
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of columns(torsions)
      real(DP) CutOff                                         !Cutoff
      real(DP) DIST(NumCol,NumCol)                            !Distance matrix
      integer, dimension(:), allocatable :: NNeig             !Number of neighbors of the i-elemt 
      integer, dimension(:,:), allocatable :: NList           !Neighbors list
      integer, dimension(:), allocatable :: COUNTER           !Counter   
      logical, dimension(:), allocatable :: Selected          !Auxiliary logical variable
      logical i_selected,j_selected,founded                   !Auxiliary logical variables
      integer i,j,k,c                                         !
      integer X(NumCol)                                       !Output: Vector whose elements indicate the ordering
                                                              !of the columns in MATRIX.dat that would minimize
                                                              !the additional terms

      integer invX(NumCol)                                    !Output: Inverse of X (i.e., invX(X(i))=i for every i)
      logical lessthan 
      logical condition
      !-----------------------------------------------------------------------------------

      allocate(Selected(NumCol))
      allocate(NNeig(NumCol))
      allocate(COUNTER(NumCol))
      allocate(NList(NumCol,NumCol))

      c=0

      do i=1,Numcol
       Selected(i)=.false.
      enddo


      do while(c.lt.NumCol)
         do i=1,NumCol
           NNeig(i)=0
         enddo
         do i=1,NumCol
           COUNTER(i)=0
         enddo

         do i=1,NumCol-1
           do j=i+1,NumCol
             if(Selected(i)) exit
             if ( lessthan ) then
                condition=(DIST(i,j)<CutOff)
             else
                condition=(DIST(i,j)>CutOff)
             endif
             if((condition).and.(.not.Selected(j))) then
                NNeig(i)=NNeig(i)+1
                NNeig(j)=NNeig(j)+1
                NList(i,NNeig(i))=j
                NList(j,NNeig(j))=i
             endif
           enddo
         enddo
         
         do k=1,NumCol
           do i=1,NNeig(k)-1
             do j=i+1,NNeig(k)
               if ( lessthan ) then
                  condition=(DIST(NList(k,i),NList(k,j)) .gt. CutOff )
               else
                  condition=(DIST(NList(k,i),NList(k,j)) .lt. CutOff )
               endif
               if( condition) COUNTER(k)=COUNTER(k)+1
             enddo
           enddo
         enddo

         founded=.false.
         do j=0,((NumCol-1)*(NumCol-2)/2)                     !J is just a counter
           do i=1,NumCol
             if((COUNTER(i)==j).and.(.not.Selected(i))) then !
               c=c+1
               Selected(i)=.true.
               X(c)=i
               invX(i)=c
               founded=.true.
               exit 
             endif
           enddo
           if(founded) exit
         enddo
      enddo  

      deallocate(Selected)
      deallocate(NNeig)
      deallocate(COUNTER)
      deallocate(NList)

      return

      END SUBROUTINE Get_Best_Ordering
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
      SUBROUTINE Get_Neighbors_Info(DIST,NumCol,CutOff,lessthan,NeigList,NumNeig)
!*****************************************************************************************
! This subroutine computes the final neighbors list for the given cutoff and the optimal
!ordering
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer, intent(IN):: NumCol                            !Number of Columns(Dihedrals)
      integer NeigList(NumCol,NumCol)                         !Final neighbors list
      integer NumNeig(NumCol)                                 !Number of neighbors of the i-element
      integer i,j,C                                           !Counters
      real(DP),intent(IN)::CutOff                             !Cutoff
      real(DP),intent(IN)::DIST(NumCol,NumCol)                !Distance matrix 
      logical lessthan,condition 
      !-----------------------------------------------------------------------------------

      !---INITIATION OF THE NUMBER OF NEIGHBORS
      do i=1,NumCol
        NumNeig(i)=0
      enddo
      !---MAKING THE NEIGHBORS LIST
      do i=1,NumCol
        C=0
        do j=i+1,NumCol
          if ( lessthan ) then 
             condition=(DIST(i,j).lt.CutOff)
          else
             condition=(DIST(i,j).gt.CutOff)
          endif
          if( condition ) then
             C=C+1
             NeigList(i,C)=j
             NumNeig(i)= NumNeig(i)+1
          endif
        enddo
      enddo
      return
      END SUBROUTINE Get_Neighbors_Info
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
      SUBROUTINE Read_Options(CutOff,MaxOrder,Method,filedat,filedist,filetable,fmtDAT,fmtDIST &
      ,NumSnap,NumSnapIni,NumCol,SnapInterval,GivenNumCol,GivenNumSnap,GivenCutoff,verbose &
      ,Reorder,Estimator,MakeCorrection,FilterCorrelation,UseCol,TextCol,Lessthan,Framestep)
!*****************************************************************************************
!This subroutine reads all the options that can be given to the 
!program through the command line
!-----------------------------------------------------------------------------------------
      use parameters
      implicit none
      !-VARIABLE DEFINITIONS--------------------------------------------------------------
      integer NumCol                                          !Number of Columns(Dihedrals) selected in MATRIX.dat
      integer NumSnapIni                                      !Initial number of Snapshots
      integer NumSnapTot                                      !Total number of rows(Snapshots) to be considered 
      integer NumSnap                                         !Number of Snapshots used on each CALC 
      integer SnapInterval                                    !Gap in snapshots between consecutive calculations (CALCs)
      integer MaxOrder                                        !Maximum order of expansion (MIE, AMIE, ...)

      logical FilterCorrelation                               !Filter false correlation? (True/False)
                                                              !(Transforms MLA into CC-MLA)

      integer Method                                          !Method, the are 3 possible values for this variable:
                                                              ! 1 - MIE 
                                                              ! 2 - AMIE 
                                                              ! 3 - MLA or CCMLA (Correlation Corrected MLA)
                                                              ! The discrimination between the two options in 3
                                                              ! is done through the "FilterCorrelation" variable

      logical Reorder                                         !Change the ordering of the dihedrals
                                                              !in order to minimize the additional terms?
                                                              !(True/False)
      logical  verbose 

      real(DP) CutOff                                         !Cutoff
      integer j,i,A,i1,C,k                                    !Counters

      logical MakeCorrection                                  !Eliminate de additional terms up to de given
                                                              !MaxOrder? (True/False)              

      logical GivenNumCol                                     !Is the number of columns (NumCol) specified? (True/False)
      logical GivenNumSnap                                    !Is the number of snapshots specified? (True/False)
      logical GivenCutoff                                     !Is the cutoff specified? (True/False)
      logical UseCol                                          !Are columns selected ? (True/False) 
      logical Lessthan                                        ! Criteria to use distance cutoff
      character*1024 TextCol                                   !Text variable for selected columns
      integer framestep                                       ! Row step for reading MATRIX.dat. Default 1 (i.e, all rows)

      real(DP) RealVar                                        !Auxiliary real variable

      character*12 fmtDAT, fmtDIST

      character*60  filedist                                  !Filename of the distance matrix file 
                                                              !Default:reduced_dist_matrix.dat

      character*60  filedat                                   !Filename of the data file (Default: MATRIX.dat).
                                                              !This file contains the discretized evolution
                                                              !of the dihedral angles 

      character*60  filetable                                 !Filename of the file where the results are
                                                              !summarized in table form

      integer ios,idummy,iargc                                !Auxiliary integer variables
      character*8  Estimator                                  !Estimator: Max-Likelihood(-ml) or Chao-Shen(-cs)
      character*1024 arg                                      !Dummy character variable
!-----------------------------------------------------------------------------------

!--READING OPTIONS
      C=0
      do i = 1, iargc()
        call getarg(i, arg)
        if((arg.eq.'-c').or.(arg.eq.'-cutoff')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) CutOff
          if(ios>0) stop "ERROR: Check CutOff. Use -help option for quick help"
          C=C+2
          GivenCutoff=.true.
          call getarg(i, arg)
        elseif(arg.eq.'-ccmla') then
          Method=3
          C=C+1
        elseif(arg.eq.'-verbose') then
          verbose=.true.
          C=C+1
        elseif(arg.eq.'-s1') then
          Method=4
          C=C+1
        elseif(arg.eq.'-s2') then
          Method=5
          C=C+1
        elseif(arg.eq.'-lt') then
          Lessthan=.true.
          C=C+1
        elseif(arg.eq.'-gt') then
          Lessthan=.false.
          C=C+1
        elseif(arg.eq.'-nor') then
          Reorder=.false.
          C=C+1
        elseif(arg.eq.'-e') then
          MakeCorrection=.true.
          C=C+1
        elseif((arg.eq.'-d').or.(arg.eq.'-data')) then
          call getarg(i+1,arg)
          read(arg,'(A60)',iostat=ios) filedat
          if(ios.ne.0)   &
          stop "ERROR: Check the file name of data matrix. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif((arg.eq.'-table').or.(arg.eq.'-t')) then
          call getarg(i+1,arg)
          read(arg,*,iostat=ios) filetable
          if(ios.ne.0) stop "ERROR: Check the table file name. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif((arg.eq.'-fmtDAT').or.(arg.eq.'-fmtdat')) then
          call getarg(i+1,arg)
          read(arg,*,iostat=ios) fmtDAT
          if(ios.ne.0) stop "ERROR: Check the fmtDAT specification. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif((arg.eq.'-fmtDIST').or.(arg.eq.'-fmtDIST')) then
          call getarg(i+1,arg)
          read(arg,*,iostat=ios) fmtDIST
          if(ios.ne.0) stop "ERROR: Check the fmtDIST specification. Use -help option for quick help"
          C=C+2
          call getarg(i, arg)
        elseif(arg.eq.'-usecol') then
          call getarg(i+1,arg)
          TextCol=arg
          UseCol=.true. 
          C=C+2
          call getarg(i, arg)
        elseif(arg.eq.'-framestep') then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) Framestep
          C=C+2
        elseif((arg.eq.'-ns').or.(arg.eq.'-nsnap')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) NumSnapIni
          read(arg,*,iostat=ios) RealVar
          if((ios.ne.0).or.(NumSnapIni.lt.1).or.(NumSnapIni.ne.int(RealVar))) then
            print*,"ERROR: Check number of snapshots. Use -help option for quick help"
            stop
          else
            C=C+2
            GivenNumSnap=.true.
            call getarg(i+2, arg)
            read(arg,*,iostat=ios) NumSnap
            read(arg,*,iostat=ios) RealVar
            if((ios.ne.0).or.(NumSnap.lt.1).or.(NumSnap.ne.int(RealVar)).or.(NumSnap.lt.NumSnapIni)) then
              NumSnap=NumSnapIni
            else
              call getarg(i+3, arg)
              read(arg,*,iostat=ios) SnapInterval
              read(arg,*,iostat=ios) RealVar
              if((ios.ne.0).or.(SnapInterval.lt.1).or.(SnapInterval.ne.int(RealVar))) then
                NumSnap=NumSnapIni
              else
                C=C+2
              endif
            endif
          endif
          call getarg(i, arg)
        elseif((arg.eq.'-nc').or.(arg.eq.'-ncol')) then
          call getarg(i+1, arg)
          read(arg,*,iostat=ios) NumCol
          read(arg,*,iostat=ios) RealVar
          if((ios.ne.0).or.(NumCol.lt.1).or.(NumCol.ne.int(RealVar)))& 
            stop "ERROR: Check number of columns. Use -help option for quick help"
          C=C+2
          GivenNumCol=.true.
          call getarg(i, arg)
        elseif(arg.eq.'-dist') then
          call getarg(i+1, arg)
          read(arg,'(A60)',iostat=ios) filedist
          if(ios.ne.0) stop "ERROR: Check the distance matrix file name. Use -help option"
          C=C+2
        elseif((arg.eq.'-help').or.(arg.eq.'-h')) then
          print*,"QUICK HELP:"
          print*,""
          print*,"SYNOPSIS:" 
          print*,"      cencalc [OPTIONS] [> Output_file.out] "
          print*,""
          print*,"OPTIONS:"
          print*," -c/-cutoff CUTOFF                            Default: 8"
          print*,""
          print*," -ns NUMBER_OF_SNAPSHOTS                      Default: Use all"
          print*,"               The are two ways to do it:"
          print*,"               -One Number                 "
          print*,"               -Three Numbers(From the first"
          print*,"                to the second every the third)"
          print*,""
          print*," -ccmla        Use CCMLA method               Default: ccmla"
          print*,""
          print*," -verbose      Print Verbose CCMLA output     Default: Deactivated"
          print*,""
          print*," -s1           Use MIE First Order Method     Default: ccmla"
          print*,""
          print*," -s2           Use MIE Second Order Method    Default: ccmla"
          print*,""
          print*," -t/-table TABLE_FILE_NAME"
          print*,"               Save principal results in"
          print*,"               table_file_name "
          print*,""
          print*," -dist REDUCED_DISTANCE_MATRIX_FILENAME       Default: reduced_dist_matrix.dat"
          print*,""
          print*," -lt           Use Dist < Cutoff criteria     Default: lt "
          print*,""
          print*," -gt           Use Dist > Cutoff criteria     Default: lt "
          print*,""
          print*," -fmtDIST  FMT_SPECIFICATION                  Default: (F9.3) "
          print*,""
          print*," -data DATA_MATRIX_FILENAME                   Default: MATRIX.dat"
          print*,""
          print*," -fmtDAT   FMT_SPECIFICATION                  Default: (I2) "
          print*,""
          print*," -nor          Do not reorder the data        Default: Deactivated"
          print*,"               Matrix before calculations"
          print*,""
          print*," -nc NUMBER_OF_COLUMNS                        Default: Use all"
          print*,""
          print*," -usecol '1-10, 15,  20-30 '                       Default: Use all"
          print*,"         Specific columns(dihedrals) or column intervals  "
          print*,"         can be handled by cencalc. Use the notation as  shown above"
          print*,"         Only numbers and commas or hyphen can be used."
          print*,"         This option invalidates the -nc option."
          print*,""
          print*," -framestep FRAME_STEP                               Default: 1"
          print*,"         Rows in MATRIX.dat are loaded with a step  "
          print*,"         equal to FRAME_STEP                        "
          print*,""
          print*," -help         Show this quick help"
          print*,""
          print*,"EXAMPLE:"
          print*,"cencalc_ccmla -c 9 -ns 10000 100000 5000 > output"
          stop
        endif
      enddo
      
      if(iargc().ne.C) stop "ERROR: Check the options. Use -help option for quick help"
      if ( UseCol ) GivenNumCol=.false. 

      return
      END SUBROUTINE Read_Options
!-----------------------------------------------------------------------------------------

!**************************************************************
        SUBROUTINE Randomize_Row(RandRow,NumSnap,idum)
!**************************************************************
        use parameters
        integer NumSnap,i,j,temp
        integer RandRow(NumSnap)
        real rand
        integer(K4B), intent(inout) :: idum         
        idum=-1

        do i=1,NumSnap
          call random_number(rand)
          j=ceiling(rand*(NumSnap-i+1) +  (i-1) )
          temp=RandRow(i)
          RandRow(i)=RandRow(j)
          RandRow(j)=temp
        enddo
        END SUBROUTINE Randomize_Row

!**************************************************************
      SUBROUTINE Select_Columns(NumCol,line,indx)
!**************************************************************
      use parameters
      integer NumCol
      character*1024 line,chunk
      integer indx(NumCol)
      integer i,j,k,L,ngroup,ipair,idummy,jdummy
!
      do i=1,NumCol
         indx(i)=0
      enddo
      i=1024  
      do while ((line(i:i) .eq. '') .and. (i .gt. 0)) 
         i=i-1
      enddo
      L=i
      ngroup=0
      k=0
!     print*,'Line=',Line(1:L),' L=',L
      do i=1,L
        if ( (line(i:i) .eq. ',') .or. ((i .eq. L) .and. (ngroup .gt. 0)) )  then
             ngroup=ngroup+1
             if ( i .eq. L ) then
                 k=k+1
                 chunk(k:k)=line(L:L)
             endif
!            print*,'preprocessed chunk=',chunk(1:k)
             ipair=index(chunk(1:k),'-')  
             if ( ipair .ne. 0) then
                chunk(ipair:ipair)=' '
                idummy=0
                jdummy=0
                read(chunk(1:k),*,err=100,end=100) idummy,jdummy
                if (( idummy .ge. 1 ) .and. ( jdummy .le. NumCol )) then
                  do j=idummy,jdummy
                     indx(j)=1
                  enddo
                endif
!               print*,'chunk=',chunk(1:k),idummy,jdummy,'L',L,'i=',i
             else  
                idummy=0
                read(chunk(1:k),*,err=100,end=100) idummy
                if ((idummy .ge. 1) .and. ( idummy .le. NumCol )) indx(idummy)=1
!               print*,'chunk=',chunk(1:k),idummy,'L',L,'i=',i
             endif
             k=0
             chunk=''
        else
             k=k+1
             chunk(k:k)=line(i:i)
        endif
      enddo
      if (  ngroup  .eq. 0 ) then 
         print*,'preprocessed line',line(1:L)
         ipair=index(line(1:L),'-')  
         line(ipair:ipair)=' '
         if ( ipair .ne. 0) then
                read(line(1:L),*,err=100,end=100) idummy,jdummy
                 do j=idummy,jdummy
                indx(j)=1
                enddo
         else 
                read(line(1:L),*,err=100,end=100) idummy
                indx(idummy)=1
         endif
      endif 
      return 
 100  continue
      write(6,'(''Error while reading selected columns in '',A40)')  chunk(1:k) 
      stop
     END SUBROUTINE Select_Columns
!

