! This is a modified version of the CENCAL code
! D. Suarez (dimas@uniovi.es) University of Oviedo 2022
! 
! The original version can be found at:
!
! https://github.com/ernestosuarez/CENCALC
!
!===================================================================
!       CONFORMATIONAL ENTROPY CALCULATION
!
! Copyright (C) 2011 Ernesto Suarez Alvarez
!
!   This program is free software: you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation, either version 3 of the License, or
!   (at your option) any later version.
!
!   This program is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   http://www.gnu.org/licenses/>.
!-----------------------------------------------------------------------------------------
!  Changes of the original code written by Dimas Suarez (dimas@uniovi.es)  2022
!-----------------------------------------------------------------------------------------
!  Any use of the CENCALC software or derivative should include at least the following
!  citation:
!
!  1)E. Suarez, N. Diaz, J. Mendez and D. Suarez. CENCALC: A Computational Tool for
!    Conformational Entropy Calculations from Molecular Dynamics Simulations.
!    J Comput Chem.  2013 ;34(23):2041-54. doi: 10.1002/jcc.23350.
!
!  The methods implemented in CENCALC are fully described in the following references:
!
!  2)E. Suarez, N. Diaz and D. Suarez. Entropy Calculations of Single Molecules by
!    Combining the Rigid-Rotor and Harmonic-Oscillator Approximations with Conformational
!    Entropy Estimations from Molecular Dynamics Simulations
!    J. Chem. Theor. Comput. 2011 , 7, 8, 2638-2653 doi: 10.1021/ct200216n
!
!  3)E. Suarez, D. Suarez. Multibody Local Approximation: Application in the Conformational
!    Entropy Calculation on Biomolecules.
!    J. Chem. Phys. 137, 084115 (2012);  doi: 10.1063/1.4748104
!
!-----------------------------------------------------------------------------------------
!     _____________________________
!    /|                           |
!    /|       MAIN PROGRAM        |
!    /|___________________________|
!    //////////////////////////////


!*****************************************************************************************
PROGRAM CENCALC_CCMLA
!*****************************************************************************************
!
! This program computes the conformational entropy from the files generated by the program
! centro_prep: "MATRIX.dat" and "reduced_dist_matrix.dat"(if a cutoff is applied).
!-----------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------
! QUICK HELP:
!
! A quick help can be viewed from the command line by typing:
! >> cencalc_ccmla -help
!-----------------------------------------------------------------------------------------
   use parameters
   IMPLICIT NONE
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of Columns(Dihedrals) in MATRIX.dat
   integer NumSelected                                     !Number of Columns(Dihedrals) Selected in MATRIX.dat
   integer NumSnapIni                                      !Initial number of Snapshots
   integer NumSnapTot                                      !Total number of rows(Snapshots) to be considered
   integer NumSnap                                         !Number of Snapshots used on each CALC
   integer SnapInterval                                    !Gap in snapshots between consecutive calculations (CALCs)
   integer NumInterval                                       !Number of Snapshot Interval
   integer MaxOrder                                        !Maximum order of expansion (MIE, AMIE, ...)
   integer,dimension (:,:),allocatable :: N(:,:)    !Data Matrix (by default, the content of MATRIX.dat)
   integer,dimension (:,:),allocatable :: tmpN(:,:) !  Auxiliary array for rellocating N if required

   integer Method                                          !Method (as defined in the original CENCALC code
   ! 1 - MIE   not  available
   ! 2 - AMIE  not  available
   ! 3 - MLA (not available) or CC-MLA
   ! 4 - S1
   ! 5 - S2

   logical shuffling                               !Filter false correlation in S2? (True/False)
   logical lowmem                                  !Logical flag to select less RAM usage
   !(Transforms MLA into CC-MLA)


   integer,dimension (:),allocatable :: X(:)               !Vector whose elements indicate the ordering
   !of the columns in MATRIX.dat that would minimize
   !the additional terms

   integer,dimension (:),allocatable :: invX(:)            !Inverse of X (i.e., invX(X(i))=i for every i)

   integer,dimension (:),allocatable :: idcol(:)

   integer,dimension (:,:),allocatable :: NeigList(:,:)    !Neighbors List. The i-row of this matrix contains
   !the list Li={Ai,...} (see the main references of
   !of the program)

   integer,dimension (:),allocatable :: NumNeig(:)         !Number of Neighbors of the i-element
   real(DP),dimension (:),allocatable :: ENTROPY(:)        !Entropy vs order: Entropy(Order) (MIE,AMIE)
   integer j,i,A,i1,C,k                                    !Counters
   real(DP),dimension (:),allocatable :: ENT_III(:)        ! CC-MLA Entropy
   real(DP),dimension (:),allocatable :: ENT_S1(:)         ! S1
   real(DP),dimension (:),allocatable :: ENT_S2(:)         ! S2        Composite calcs
   real(DP),dimension (:),allocatable :: ENT_CCMLA(:)      ! CCMLA
   real(DP) CutOff                                         !Cutoff
   real(DP) MaxDist                                        !Maximum value in the distance matrix
   integer ios                                             ! I/O state

   logical Reorder                                         !Change the ordering of the dihedrals
   !in order to minimize the additional terms?
   !(True/False)
   logical   lessthan                                      ! Criteria to apply distance cutoff
   real(DP), dimension (:,:),allocatable :: DistIni(:,:)   !Reduced distance matrix before reordering
   real(DP), dimension (:,:),allocatable :: DIST(:,:)      !Reduced distance matrix after reordering
   real(DP), dimension (:),allocatable ::   S1(:,:)          !Marginal entropies
   real(DP), dimension (:,:),allocatable :: S2(:,:,:)        !Second-order entropies

   logical MakeCorrection                                  !Eliminate de additional terms up to de given
   !MaxOrder? (True/False)

   logical GivenNumCol                                     !Is the number of columns (NumCol) specified? (True/False)
   logical GivenNumSnap                                    !Is the number of snapshots specified? (True/False)
   logical GivenCutoff                                     !Is the cutoff specified? (True/False)
   logical UseCol                                          !Are columns selected ? (True/False)
   logical S1Calc                                          !Do just first-order calc.
   logical S2Calc                                          !Use MIE Second-Order method ?  (True/False)
   logical S2Filt                                          ! Activate S2-based filtering of dihedrals
   logical PrintS2                                         ! Logical Flag to printS1 values and the  S2 coor matrix
   logical ReadS2                                          ! Logical Flag to read S1 and S2 corr matrix
   real(DP) CutS2F1,CutS2F2                                ! Cutoff in absolute value of S2 corr

   logical verbose                                         !Print statistical data about CCMLA states (True/False)
   integer Framestep                                       !Row step for reading MATRIX.dat. Default = 1 (i.e. all rows)
   character*1024 TextCol                                  !Text variable for selected columns
   integer,dimension (:),allocatable :: selected(:)        !Pointer to selected columns (dihedrals) in input data file
   integer,dimension (:),allocatable :: selected_S1(:)     !Pointer to selected columns
   integer,dimension (:),allocatable :: selected_S2(:)     !Pointer to selected columns   Composite Calcs
   integer NumSelected_S1                                  !Number of Columns(Dihedrals) for S1 (Comp. calcs)
   integer NumSelected_S2                                  !Number of Columns(Dihedrals) for S2 (Comp. calcs)

   character*12  fmtDIST, fmtDAT                           ! Data Format

   character*60  filedist                                  !Filename of the distance matrix file
   !Default:reduced_dist_matrix.dat

   character*60  filedat                                   !Filename of the data file (Default: MATRIX.dat).
   !This file contains the discretized evolution
   !of the dihedral angles

   character*60  filetable                                 !Filename of the file where the results are
   !summarized in table form

   character*60  fileps2mat                                 !Filename of the file where S1 and S2 coor are printed
   character*60  filers2mat                                 !Filename of the file where S1 and S2 coor are read

   character*1024 arg                                      !Dummy character variable
   character*8 Estimator                                   !Estimator: Max-Likelihood(-ml) or Chao-Shen(-cs)
   integer CALC                                            !Counter for the number of calculations
   real(DP),dimension (:),allocatable :: CORRECTION(:)     !Entropy Correction to eliminate the additional terms

   !in function "ran"
   integer ii,jj                                           ! Some Auxiliary variables
   integer NumProcs, NumThreads, OMP_get_num_procs, OMP_get_num_threads

   character*1024 cdummy
   integer idummy
   real(DP) dummy
   integer, dimension (:),allocatable ::   ivec_dummy(:)
   real(DP), dimension (:),allocatable ::  vec_dummy(:)
   real(DP), dimension (:),allocatable ::  mat_dummy(:,:)
   logical LA,LB
   !-----------------------------------------------------------------------------------


   write(*,'(A33)') " _______________________________ "
   write(*,'(A33)') "||  _____                       |"
   write(*,'(A33)') "||  \\   ||                     |"
   write(*,'(A33)') "||   \\  PROGRAM CENCALC_CCMLA  |"
   write(*,'(A33)') "||   //     using quicksort     |"
   write(*,'(A33)') "||  //___||                     |"
   write(*,'(A33)') "||______________________________|"
   print*," "

   CALL Tick_Time('')   ! Setting tick time

!---DEFAULT/INITIAL VALUES----------------------------------------------------------------
   filedat='MATRIX.dat'
   filedist='reduced_dist_matrix.dat'
   filetable='TABLE.out'
   fileps2mat='S1_S2_MAT.dat'
   filers2mat='S1_S2_MAT.dat'
   CutOff=8.0d0
   MaxOrder=2
   MaxDist=0.d0
   UseCol=.false.
   GivenNumCol=.false.
   GivenNumSnap=.false.
   GivenCutoff=.false.
   SnapInterval=1000
   Method=3
   Reorder=.true.
   MakeCorrection=.false.
   shuffling=.false.
   s1calc=.false.
   s2calc=.false.
   s2filt=.false.
   prints2=.false.
   reads2=.false.
   CutS2F1=0.01d0
   CutS2F2=0.01d0
   verbose=.false.
   lessthan=.true.
   Estimator="ml"
   lowmem=.false.
   Framestep=1
   fmtDIST='(F9.3)'
   fmtDAT='(I2)'
!------OMP info----------------------------------------------------------------------------------
   NumProcs = 1
   NumThreads = 1
!$omp parallel
!$ NumProcs = OMP_get_num_procs()
!$ NumThreads = OMP_get_num_threads()
!$omp end parallel

! Number of Threads cannot be greater than NumProcs since
! we request paralell IO of data files
!$ print*,'OMP Parallel Execution'
!$ print*,"Number of Processors=",NumProcs
!$ print*,"Number of Threads   =",NumThreads
!$ if ( NumThreads > NumProcs ) then
!$    call OMP_set_num_threads(NumProcs)
!$    print*,'Number of Threads set to ',NumProcs
!$ endif


!---READING OPTIONS-----------------------------------------------------------------------
   CALL Read_Options(CutOff,MaxOrder,Method,filedat,filedist,filetable &
      ,fileps2mat,filers2mat,printS2,readS2,fmtDAT,fmtDIST  &
      ,NumSnap,NumSnapIni,NumCol,SnapInterval,GivenNumCol,GivenNumSnap,GivenCutoff,verbose &
      ,Reorder,Estimator,MakeCorrection,shuffling,UseCol,TextCol,Lessthan,Framestep &
      ,S2Filt,CUTS2F1,CUTS2F2,lowmem)
!-----------------------------------------------------------------------------------------
!---READING THE REDUCED-DISTANCE-MATRIX IF THE CUTOFF IS GREATER OR EQUAL ZERO------------
   if(CutOff.ge.0.0d0) then
      write(*,'(A30)')" Reading the distance matrix..."
      write(*,*)"filename: ",filedist
      MaxDist=0d0

      open(3,file=filedist,status='old',iostat=ios)           !Opening the distance matrix file
      if(ios.ne.0) then
         print*,"Error during opening of ",filedist
         stop
      endif

      if(.not.GivenNumCol) then    !If NumCol is not specified,
         C=0                  !count how many columns there are
         ios=0
         do while(ios==0)
            read(3,fmtDIST,iostat=ios,advance='no') dummy !Just to know the number of columns
            if(ios>0) then
               print*,"Error(2) while reading (using format ",fmtDIST," ) ",filedist
               stop
            endif
            if(ios<0) exit
            C=C+1
         enddo
         rewind(3)

         A=0
         ios=0
         do while(ios==0)
            read(3,*,iostat=ios) dummy                    !Just to know the number of rows
            if(ios>0) stop "Error(3) while reading reduced_dist_matrix.dat"
            if(ios==-1) exit
            A=A+1
         enddo
         rewind(3)

         if(A.eq.C) then
            NumCol=C
         else
            Stop "Error(4) The number of columns and rows are not the same"
         endif
      endif

      allocate(DistIni(NumCol,NumCol))
      allocate(DIST(NumCol,NumCol))
      allocate(X(NumCol))
      allocate(invX(NumCol))
      allocate(selected(NumCol))
      allocate(idcol(NumCol))
!
!     If we use specific columns then selected(i)=0/1 for dihedral i
!     discarded/selected. X is used here as temporary array
!
      if (UseCol )  then
         cdummy=TextCol
         call Select_Columns(NumCol,cdummy,selected)
         NumSelected=0
         do i=1,NumCol
            if ( selected(i) .eq. 1) then
               NumSelected=NumSelected+1
               X(NumSelected)=i
            endif
         enddo
         if ( NumSelected .eq. 0 ) STOP 'no columns have been selected!'
         do i=1,NumSelected
            selected(i)=X(i)
            idcol(i)=selected(i)
            X(i)=0
         enddo
!
      else
         NumSelected=NumCol
         do i=1,NumSelected
            selected(i)=i
            idcol(i)=selected(i)
         enddo
      endif
!
      do i=1,NumCol
         read(3,'(10000'//fmtDIST//')',iostat=ios)(DistIni(i,j),j=1,NumCol)
         do j=1,NumCol
            DistIni(i,j)=abs(DistIni(i,j))
         enddo
         if(ios>0) then
            print*,"Error(1) while reading ",filedist
            stop
         elseif(ios<0) then
            print*,"Error(1) Unexpected end of file or record"
            stop
         endif
      enddo
!
!      If UseCol then we prune the DistIni matrix in terms of the
!      reduced number of columns. DIST is used here as a temporary
!      array.
!
      if ( UseCol) then
         do ii=1,NumSelected
            i=selected(ii)
            do jj=1,NumSelected
               j=selected(jj)
               DIST(ii,jj)=DistIni(i,j)
            enddo
         enddo
         do ii=1,NumSelected
            do jj=1,NumSelected
               DistIni(ii,jj)=DIST(ii,jj)
            enddo
         enddo
      endif
!
      do i=1,NumSelected
         X(i)=i                                                 !Initial values for X
         invX(i)=i                                              !and invX
      enddo

      if(Reorder) then      !Getting the  actual values for X and invX
         ! X:    Reordered array of selected torsions to minimize additional
         !       terms. Since X elements are themselves indexes, X i used
         !       to reorder the DIST elements
         !
         ! invX: Index array keeping track of original and final ordering
         !       invX(1)=4  ----> First torsion (1) becomes fourth (4)
         !
         CALL Get_Best_Ordering(DistIni(1:NumSelected,1:NumSelected),NumSelected,CutOff,lessthan,X,invX)

         print*,'# of columns to be read=',NumSelected,' out of ',NumCol
         if ( verbose ) then
            print*,'Best ordering has been applied'
            print*,'==================================='
            print*,' Original_Numbering  '
            write(*,'(20(I5,'',''))') (selected(i),i=1,NumSelected)
            print*,'==================================='
            print*,' New_Numbering'
            write(*,'(20(I5,'',''))') (invX(i),i=1,NumSelected)
            print*,'==================================='
         endif
         do i=1,NumSelected
            idcol(invX(i))=selected(i)
         enddo
      endif

      do i=1,NumSelected
         do j=1,NumSelected
            DIST(i,j)=DistIni(X(i),X(j))                         !Reordering the distance matrix
            if(DIST(i,j).gt.MaxDist) MaxDist=DIST(i,j)           !taking into account the vector X
         enddo                                                 !Once that X is used here, it can be
      enddo                                                   !overwritten for other purposes
      CALL Tick_Time('Distance Matrix Processing')
   endif  ! READING DIST DATA
!-----------------------------------------------------------------------------------------

!---READING THE DATA MATRIX---------------------------------------------------------------
   write(*,*)" "
   write(*,'(A26)')" Reading the data matrix..."
   write(*,*)"filename: ",filedat
   open(2,file=filedat,status='old',iostat=ios)
   if(ios.ne.0) then
      print*,"Error during opening of ",filedat
      stop
   endif

   if(.not.GivenNumCol) then                             !If NumCol is not specified,
      A=0                                                !count how many columns there are
      ios=0
      do while(ios==0)
         read(2,fmtDAT,iostat=ios,advance='no') idummy     !Just to know the number of columns
         if(ios>0) then
            print*,"Error(5) while reading(using format",fmtDAT,") ",filedat
            stop
         endif
         if(ios<0) exit
         A=A+1
      enddo
      if((A.ne.NumCol).and.(CutOff.ge.0d0)) stop  &
         "Error(55) The number of columns of the distance matrix and &
      &the data file are not the same"
      NumCol=A
   endif
   rewind(2)

   if(.not.GivenNumSnap) then                            !If NumSnap is not specified,
      A=0                                                !count how many rows there are
      ios=0                                              !in the data matrix
      do while(ios==0)
         read(2,*,iostat=ios) dummy                        !Just to know the number of snapshots(rows)
         if(ios>0) stop "Error(6) while reading the data file"
         if(ios==-1) exit
         A=A+1
      enddo
      NumSnap=A
      NumSnapIni=A
      print'(A,I8)',"Number of Snapshots read:",NumSnap
   endif
   rewind(2)

   if (Cutoff .lt. 0.0d0)  then
      allocate (X(NumCol))
      allocate (invX(NumCol))
      allocate (selected(NumCol))
      allocate (idcol(NumCol))
!
!        If no cutoff is used then UseCol must be processed here
!        before reading MATRIX.dat
!
      if ( UseCol )   then
         cdummy=TextCol
         call Select_Columns(NumCol,cdummy,selected)
         NumSelected=0
         do i=1,NumCol
            if ( selected(i) .eq. 1) then
               NumSelected=NumSelected+1
               X(NumSelected)=i
            endif
         enddo
         if ( NumSelected .eq. 0) STOP 'No columns have been selected'
         do i=1,NumSelected
            selected(i)=X(i)
            idcol(i)=selected(i)
            X(i)=0
         enddo
      else
         NumSelected=NumCol
         do i=1,NumCol
            selected(i)=i
            idcol(i)=selected(i)
         enddo
      endif

   endif
!  print*,'NumSelected=',NumSelected
!
!     Read the big matrix
!
   allocate(N(NumSnap,NumSelected)) !----------------------!Once the exact number of columns and rows
   !to be considered in the data matrix are
   !known, then allocate N and save the info on it.
   k=0
   do i=1,NumSnap
!
!       X is used here as a temporary array
!
      read(2,'(10000'//fmtDAT//')',iostat=ios) (X(j),j=1,NumCol)

      if(ios>0) then
         print*,"Error(7) while reading ",filedat
         stop
      elseif(ios<0) then
         print*,"Error(7) Unexpected end of ",filedat
         print*,"If you have specified the Num of Snapshots using -ns,"
         print*,"then check that the number of rows in ",filedat
         print*,"is greater than or equal to the specified Num of Snapshots"
         stop
      endif

      if ( (i/Framestep)*Framestep .eq. i ) then

         k=k+1

         if (CutOff.ge.0.0d0) then     !--------Read the data matrix taking into account the optimal
            do jj=1, NumSelected           !ordering given by X, or specifically, given by invX
               N(k,invX(jj))=X( selected(jj) )
            enddo
         else            !---------------If cutoff<0 (infinite cutoff) read the data matrix normally
            do jj=1, NumSelected
               N(k,jj)=X( selected(jj) )
            enddo
         endif


      endif

   enddo

   if ( Framestep .gt. 1 ) then
      print*,' framestep=',Framestep
      print*,' Only ',k,' evenly-spaced snapshots are loaded for Entropy calcs'
      NumSnap=k
      print*,' NumSnap reassigned value=',k
      allocate(tmpN(NumSnap,NumSelected))
      tmpN=N(1:NumSnap,:)
      call move_alloc(tmpN, N)
   endif

   do i=1,NumSnap
      do j=1,NumSelected
         N(i,j)=N(i,j)-1    !  For coding the rows of N into a big integer number
      enddo
   enddo
!
   NumCol=NumSelected !
   NumSnapTot=NumSnap !------------------------------------!Actually, at this point NumSnap and NumSelected
   ! are the total number of snapshots and columns considered,
!
!   Obtaining NeigList
!

   allocate(NumNeig(NumCol))
   allocate(NeigList(NumCol,NumCol))
   if ((cutoff.gt. 0.0d0 ) .and. (CutOff.gt.MaxDist)) then
      print*,"WARNING: CutOff bigger than MaxDistance in Distance Matrix"
      print*,"Using no cutoff "
      cutoff=-1.0d0
   endif
   if ( cutoff .le. 0.d0 ) then
      do i=1,NumCol
         k=0
         NumNeig(i)=0
         do j=i+1,NumCol
            k=k+1
            NeigList(i,k)=j
            NumNeig(i)= NumNeig(i)+1
         enddo
      enddo
   else
      CALL Get_Neighbors_Info(DIST(1:NumCol,1:NumCol),NumCol,CutOff,Lessthan,NeigList,NumNeig)
   endif
!
   CALL Tick_Time('MATRIX load and processing')
!
!---END OF READING THE DATA MATRIX---------------------------------------------------------------

!---CALCULATING THE ENTROPY---------------------------------------------------------------

   write(*,*) " "
   write(*,'(A25)') "-------------------------"
   write(*,'(A25)') " CALCULATING THE ENTROPY "
   write(*,'(A25)') "-------------------------"

   if((MaxOrder.gt.NumCol).and.((Method.eq.1).or.(Method.eq.2))) then
      print*,"WARNING: Order is greater than the number of Columns"
      print*,"         NumColumns will be taken as MaxOrder"
      MaxOrder=NumCol
   endif
   if ( UseCol ) then
      print*,"WARNING: Using only data from columns ",TextCol
   endif

   open(1,file=filetable,status='replace')

   print'(A25)',  "========================="          !
   if(Estimator.eq."cs") &                             !
      write(*,'('' Estimator: Chao-Shen (requested, but currently not implemented)'')')        !
   if(Estimator.eq."ml") &                             !
      write(*,'('' Estimator: Max-Likelihood'')')    !
   S1CALC=(Method.eq.4)
   S2CALC=(Method.eq.5)
   if(S1Calc) then
      write(*,'('' Method: S1=MIE 1st-order'')')    !
   elseif(S2Calc) then
      write(*,'('' Method: S2=MIE 2nd-order'')')    !
   else
      write(*,'('' Method: CC-MLA '')')    !
      if ( verbose ) then 
         write(*,'('' WARNING: Verbose output is requested (activating LowMem)!'')')    !
         lowmem=.true.
      endif
   endif
   if (S2Filt) then
      write(*,'(''       S2 corr cutoff (1)='',F8.5)') CUTS2F1    !
      write(*,'(''       S2 corr cutoff (2)='',F8.5)') CUTS2F2    !
   endif
   if ( ( lessthan ) .and. (CutOff.gt. 0.d0) )  then
      write(*,'('' Distance < Cut-Off='',F8.5)') Cutoff     !
   else if ( CutOff .gt. 0d0 ) then
      write(*,'('' Distance > Cut-Off='',F8.5)') Cutoff     !
   else
      write(*,'('' Cut-Off='',F8.5)') Cutoff     !
   endif
   if (lowmem) then
      write(*,'(''WARNING: LowMem option activated. '')') 
   endif
   write(*,'('' Number of Snapshots='',I8)') NumSnapTot   !
   write(*,'('' Number of Columns  ='',I8)') NumCol
   print'(A25)',  "========================="          !


   NumInterval=int( ( NumSnapTot-NumSnapIni )/SnapInterval) + 1
   allocate(ENT_III(NumInterval))

   call random_seed()
!
   if ( ( S2CALC ) .or. ( S1CALC ) .or. ( S2FILT )  ) then

      allocate(S1(NumCol,NumInterval))
      allocate(S2(NumCol,NumCol,NumInterval))

      if (S2FILT) then

         allocate(ENT_S1(NumInterval))
         allocate(ENT_S2(NumInterval))
         allocate(ENT_CCMLA(NumInterval))
         allocate(selected_S1(NumCol))
         allocate(selected_S2(NumCol))

      endif


      if ( READS2 ) then

         write(*,*)" "
         write(*,'(A26)')"Reading S1 array and S2 matrix..."
         write(*,*)"filename: ",filers2mat
         open(4,file=filers2mat,status='old',iostat=ios)
         if(ios.ne.0) then
            print*,"Error during opening of ",filers2mat
            stop
         endif
         read(4,*)
         read(4,'(2I4)') i,j     !  i --> NumCol_FILE   j---> NumInterval_File
         read(4,*)
         if (( NumCol .ne. i ) .or. ( NumInterval .ne. j ))  then
            write(*,'('' NumCol and NumInterval dimensions in '',A40, &
               '' are not consistent '')') filers2mat
            write(*,'(''Current NumCol='',I4,'' Datafile NumCol='',I4)') NumCol, i
            write(*,'(''Current NumInterval='',I4,'' Datafile NumInterval='',I4)') NumInterval, j
            stop
         endif
         invX=0   ! invX used here as temporary array
         do i=1,NumCol
            read(4,'(I4,100(2X,F12.8))') invX(i),(S1(i,k),k=1,NumInterval)
         enddo
         read(4,*)
         do k=1,NumInterval
            read(4,'(A)') arg
            if (index(arg,'Interval').eq.0) backspace(4) 
            do i=1,NumCol
               read(4,'(1000(F12.8))') (S2(i,j,k),j=1,NumCol)
            enddo
         enddo
         close(4)
         ! Reordering of S1 and S2 will be necessary
         X=0
         do i=1,NumCol
            do j=1,NumCol
               if ( idcol(i) .eq. invX(j) ) then
                  X(j)=i
                  exit
               endif
            enddo
         enddo
         do i=1,NumCol
            if (X(i) .eq. 0 ) then
               write(*,'(''Column '',I4,'' in datafile cannot be assigned!'')') i
               write(*,'(''Files2mat='',A40,'' is not compatiable with current run'')') filers2mat
               stop
            endif
         enddo
         allocate(vec_dummy(NumCol))
         do k=1,NumInterval
            do i=1,NumCol
               vec_dummy(X(i))=S1(i,k)
            enddo
            S1(:,k)=vec_dummy
         enddo
         deallocate (vec_dummy)
         allocate (mat_dummy(NumCol,NumCol))
         do k=1,NumInterval
            do i=1,NumCol
               do j=1,NumCol
                  mat_dummy(X(i),X(j))=S2(i,j,k)
               enddo
            enddo
            S2(:,:,k)=mat_dummy
         enddo
         deallocate (mat_dummy)
         CALL Tick_Time(' Reading S1/S2')

      else

         print'(A25)',  "========================="          !
         if ((S2CALC) .or. (S2FILT))  then
            print*,"Computing S1 and S2 Correlation Matrix"          !
            if (shuffling) print*,"...... including shuffling correction!"
         else
            print*,"Computing S1 (Marginal entropies)"          !
         endif
         CALL S1_S2_calc(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumCol,NeigList,   &
            NumNeig,ENT_III,S1,S2,CutOff,Estimator,s1calc,shuffling,lowmem)
         CALL Tick_Time(' Computing S1/S2')

      endif

      if (( PRINTS2 ) .and. ((S2CALC).or.(S2FILT)) ) then
         write(*,*)" "
         write(*,'(A)')" Writing S1 array and S2 matrix..."
         write(*,*)"filename: ",fileps2mat
         open(4,file=fileps2mat,status='unknown',iostat=ios)
         if(ios.ne.0) then
            print*,"Error during opening of ",fileps2mat
            stop
         endif
         write(4,'(''#  Number of Torsions and Number of Intervals '')')
         write(4,'(2I4)') NumCol,NumInterval
         write(4,'(''#  Original numbering and First Order Entropies (one column per interval) '')')
         do i=1,NumCol
            write(4,'(I4,100(2X,F12.8))') idcol(i),(S1(i,k),k=1,NumInterval)
         enddo
         write(4,'(''# Matrix of Second Order Corrections (one matrix per interval) Cutoff='',F8.3)') CutOff
         do k=1,NumInterval
            write(4,'(''# Interval='',I4)') k
            do i=1,NumCol
               write(4,'(1000(F12.8))') (S2(i,j,k),j=1,NumCol)
            enddo
         enddo
         write(4,'(''# Original numbering and correlation index of each torsion (one column per interval)'' )')
         allocate (mat_dummy(NumCol,NumInterval))
         mat_dummy=0.0d0
         do k=1,NumInterval
            do i=1,NumCol
               mat_dummy(i,k)=sum(S2(i,:,k))/2.0d0
            enddo
         enddo
         do i=1,NumCol
            write(4,'(I4,100(2X,F12.8))') idcol(i),(mat_dummy(i,k),k=1,NumInterval)
         enddo
         deallocate(mat_dummy)
         close(4)
         CALL Tick_Time(' Printing S1/S2')
      endif

      if ( S2FILT ) then  !  BEGINNING OF S2FILT BLOCK

         X=0                 ! X and invX are used here as temporary arrays
         invX=0
         NumSelected_S1=0
         NumSelected_S2=0
         selected_S1=0
         selected_S2=0
         NumSelected=0       ! NumSelected_CCMLA
         selected=0          ! selected_CCMLA

         do i=1,NumCol
            dummy=maxval(abs(S2(i,:,NumInterval)))
            if ( dummy  .gt. CutS2F2 ) then
               invX(i)=1
            else if ( dummy .le. CutS2F1) then
               invX(i)=-1
            else
               invX(i)=0
            endif
         enddo

         do i=1,NumCol
            if ( invX(i) .eq. -1 ) then
               NumSelected_S1=NumSelected_S1+1
               selected_S1(NumSelected_S1)=i
               X(NumSelected_S1)=idcol(i)
            endif
         enddo
         write(*,'(''Selecting i,j torsions with |S2(i,j)| <='',F8.3)') CutS2F1
         print*,'# of columns to be used in S1=',NumSelected_S1,' out of ',NumCol
         if ( ( verbose ) .and. ( NumSelected_S1 .gt. 0 ) ) then
            print'(A25)',  "================================="          !
            write(*,'(''    Columns_in_S1 (Orig. Numbering) '')')
            print'(A25)',  "================================="          !
            write(*,'(20(I5,'',''))') (X(i),i=1,NumSelected_S1)
         endif
         print'(A25)',  "================================="          !

         X=0
         do i=1,NumCol
            if ( invX(i) .eq.  0 ) then
               NumSelected_S2=NumSelected_S2+1
               selected_S2(NumSelected_S2)=i
               X(NumSelected_S2)=idcol(i)
            endif
         enddo
         write(*,'(''Selecting i,j torsions with'',F8.3,''< |S2(i,j)| <='',F8.3)') CutS2F1,CutS2F2
         print*,'# of columns to be used in S2=',NumSelected_S2,' out of ',NumCol
         if ( ( verbose ) .and. ( NumSelected_S2 .gt. 0 ) ) then
            print'(A25)',  "================================="          !
            write(*,'(''    Columns_in_S2 (Orig. Numbering) '')')
            print'(A25)',  "================================="          !
            write(*,'(20(I5,'',''))') (X(i),i=1,NumSelected_S2)
         endif
         print'(A25)',  "================================="          !

         X=0
         do i=1,NumCol
            if ( invX(i) .eq. 1 ) then
               NumSelected=NumSelected+1
               selected(NumSelected)=i
               X(NumSelected)=idcol(i)
            endif
         enddo
         idcol=X
         X=0
         invX=0

         write(*,'(''Selecting i,j torsions with |S2(i,j)| >'',F8.3)') CutS2F2
         print*,'# of columns to be used in CCMLA=',NumSelected,' out of ',NumCol
         if ( verbose ) then
            print'(A25)',  "================================="          !
            write(*,'(''    Columns in CCMLA(Orig. Numbering) '')')
            print'(A25)',  "================================="          !
            write(*,'(20(I5,'',''))') (idcol(i),i=1,NumSelected)
         endif
         print'(A25)',  "================================="          !


         if ( NumSelected_S1 .gt. 0 ) then
            print*," Collecting S1 data "
            ENT_S1=0.0d0
            do k=1,NumInterval
               do i=1,NumSelected_S1
                  ENT_S1(k)=ENT_S1(k)+S1(selected_S1(i),k)
                  S2(selected_S1(i),:,k)=0.0d0       !  Zeroing any S2 terms involving S1 torsions
                  S2(:,selected_S1(i),k)=0.0d0
               enddo
            enddo
         else
            ENT_S1=0.0d0
         endif

         if ( NumSelected_S2 .gt. 0 ) then
            ENT_S2=0.0d0
            print*," Collecting S2 data "

            if ( NumSelected .gt. 0 )  then  !Zeroing CCMLA:CCMLA S2 terms
               do i=1,NumSelected
                  ii=selected(i)
                  do j=i+1,NumSelected
                     jj=selected(j)
                     S2(ii,jj,:)=0.0d0
                     S2(jj,ii,:)=0.0d0
                  enddo
               enddo
            endif

            ! We incorporate all correlation pairs involving S2:S2 and S2:CCMLA torsions. For simplicity, we run
            ! the loop over all columns after having zeroed S2 elements involving any S1 torsion and CCMLA:CCMLA
            ! torsions. In this way, we take advantage of the NumNeig/NeigList arrays to make sure that
            ! we only incorporate contributions within the given cutoff

            do k=1,NumInterval

               do i=1,NumSelected_S2   !  First order terms of selected S2 torsions
                  ENT_S2(k)=ENT_S2(k)+S1(selected_S2(i),k)
               enddo

               do i=1,NumCol
                  do j=1,NumNeig(i)
                     ENT_S2(k)=ENT_S2(k)+S2(i,NeigList(i,j),k)
                  enddo
               enddo

            enddo

         else
            ENT_S2=0.0d0
         endif

         if  (NumSelected .gt. 0 ) then
            if  (Cutoff.gt.0.0d0 ) then
               DistIni=DIST    ! DIST is the pruned (if USECOL) and reordered (if REORDER) distance matrix
               ! In the composite protocol, we continue pruning/reordering this
               ! matrix before doing the CCMLA calcs

               do ii=1,NumSelected
                  i=selected(ii)
                  do jj=1,NumSelected
                     j=selected(jj)
                     DIST(ii,jj)=DistIni(i,j)
                  enddo
               enddo
               NumNeig=0
               NeigList=0

               if(Reorder) then

                  X=0
                  invX=0
                  do i=1,NumSelected
                     X(i)=i                     !Initial values for X
                     invX(i)=i                  !and invX
                  enddo
                  do ii=1,NumSelected
                     do jj=1,NumSelected
                        DistIni(ii,jj)=DIST(ii,jj)
                     enddo
                  enddo

                  CALL Get_Best_Ordering(DistIni(1:NumSelected,1:NumSelected),NumSelected,CutOff,lessthan,X,invX)
                  if ( verbose ) then
                     print*,'Best ordering has been applied again'
                     print*,'==================================='
                     print*,' Original_Numbering  '
                     write(*,'(20(I5,'',''))') (idcol(i),i=1,NumSelected)
                     print*,'==================================='
                     print*,' New_Numbering'
                     write(*,'(20(I5,'',''))') (invX(i),i=1,NumSelected)
                     print*,'==================================='
                  endif

                  allocate ( ivec_dummy(NumSelected))
                  ivec_dummy=0
                  do i=1,NumSelected
                     ivec_dummy(invX(i))=idcol(i)
                  enddo
                  idcol(1:NumSelected)=ivec_dummy
                  deallocate(ivec_dummy)

                  do i=1,NumSelected
                     do j=1,NumSelected
                        DIST(i,j)=DistIni(X(i),X(j))                         !Reordering the distance matrix
                     enddo
                  enddo

               endif
               CALL Get_Neighbors_Info(DIST(1:NumSelected,1:NumSelected),NumSelected,    &
                  CutOff,Lessthan,NeigList(1:NumSelected,1:NumSelected),NumNeig(1:NumSelected))
            else
               NumNeig=0
               NeigList=0
               do i=1,NumSelected
                  k=0
                  NumNeig(i)=0
                  do j=i+1,NumSelected
                     k=k+1
                     NeigList(i,k)=j
                     NumNeig(i)= NumNeig(i)+1
                  enddo
               enddo
            endif

            allocate (tmpN(NumSnapTot,NumSelected))
            if ((CutOff.ge.0.0d0) .and.(Reorder)) then
               do jj=1, NumSelected
                  tmpN(:,invX(jj))=N(:, selected(jj) )
               enddo
            else
               do jj=1, NumSelected
                  tmpN(:,jj)=N(:, selected(jj) )
               enddo
            endif
            deallocate(N)
            CALL Tick_Time(' Setting CC-MLA calc')
            print*," Computing CCMLA data "
            if ( verbose ) then 
            CALL CCMLA_CALC(tmpN,    &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumSelected,   &
               NeigList(1:NumSelected,1:NumSelected),NumNeig(1:NumSelected),      &
               ENT_CCMLA,CutOff,Estimator,verbose,idcol(1:NumSelected))
            else
            CALL CCMLA_CALC_OMP(tmpN,    &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumSelected,   &
               NeigList(1:NumSelected,1:NumSelected),NumNeig(1:NumSelected),      &
               ENT_CCMLA,CutOff)
            endif
            deallocate(tmpN)
    
            CALL Tick_Time(' Computing CCMLA')

         else
            ENT_CCMLA=0.0d0
         endif

         ENT_III = ENT_S1 + ENT_S2 +  ENT_CCMLA

      endif  ! ---> ENDING S2FILT BLOCK

   else

   ! if RAM swapping/depletion is observed  (small RAM or very large dataset) lowmem may help.

      if ((verbose) .or. (lowmem)) then 
      CALL CCMLA_CALC(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumSelected,NeigList,   &
         NumNeig,ENT_III,CutOff,Estimator,verbose,idcol(1:NumSelected))
      else
      CALL CCMLA_CALC_OMP(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumSelected,NeigList,   &
         NumNeig,ENT_III,CutOff)
      endif
      deallocate(N)
      CALL Tick_Time(' Computing CCMLA')

   endif
   !------------------------------------------------------------------

   !----------------------------------------------------!Write Results
   write(*,*) " "
   write(*,'(A43)') "------------------------------------        "
   write(*,'(A43)') " ESTIMATED ENTROPY (cal/mol-Kelvin)         "
   write(*,'(A43)') "------------------------------------        "
   write(*,'(A9,A12)') "# NumSnap","Entropy"
   write(*,'(I9,100F12.4)') NumSnap, ENT_III
   k=0
   if ( S2FILT ) then
      write(1,'(''# Cutoff='',F8.3,'' CutS2F1='',F8.3,'' CutS2F2='',F8.3)') Cutoff,CutS2F1,CutS2F2
      write(1,'(''# NumSnap   S1('',I3,'')  S2('',I3,'')  CCMLA(''I3'') Composite'')')   &
         NumSelected_S1,NumSelected_S2,NumSelected
      do NumSnap=NumSnapIni,NumSnapTot,SnapInterval
         k=k+1
         write(1,'(I9,50F12.4)') NumSnap, ENT_S1(k),ENT_S2(k),ENT_CCMLA(k),ENT_III(k)
      enddo
   else
      if ( S1CALC ) then
         write(1,'(''# First Order Entropy '')')
         write(1,'(A9,A12)') "# NumSnap", "Entropy"
         do NumSnap=NumSnapIni,NumSnapTot,SnapInterval
            k=k+1
            write(1,'(I9,50F12.4)') NumSnap, ENT_III(k)
         enddo
      else if (S2CALC) then
         write(1,'(''# First and  Second Order Entropy  Cutoff='',F8.3)') Cutoff
         write(1,'(''# NumSnap  First-order Second-order  Entropy(total) '',F8.3)') Cutoff
         do NumSnap=NumSnapIni,NumSnapTot,SnapInterval
            k=k+1
            write(1,'(I9,50F12.4)') NumSnap,sum(S1(:,k)),ENT_III(k)-sum(S1(:,k)),ENT_III(k)
         enddo
      else
         write(1,'(''# CCMLA Entropy Cutoff='',F8.3)') Cutoff
         write(1,'(A9,A12)') "# NumSnap", "Entropy"
         do NumSnap=NumSnapIni,NumSnapTot,SnapInterval
            k=k+1
            write(1,'(I9,50F12.4)') NumSnap, ENT_III(k)
         enddo
      endif
   endif


   close(1)
   close(2)
   close(3)

   CALL Tick_Time('Total')

   STOP                                                    !----------FINISH-----------
!-----------------------------------------------------------------------------------------
END PROGRAM CENCALC_CCMLA
!-----------------------------------------------------------------------------------------
!      _____________________________
!     /|                           |
!     /| SUBROUTINES AND FUNCTIONS |
!     /|___________________________|
!     //////////////////////////////

!*****************************************************************************************
SUBROUTINE S1_S2_calc(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot     &
   ,NumCol,NeigList,NumNeig           &
   ,Entropy,S1,S2,CutOff,Estimator,s1calc,shuffling,lowmem)
   !
   !*****************************************************************************************
   !As the name implies, this subroutine computes the MIE second-order entropy
   !using the given cutoff
   !-----------------------------------------------------------------------------------------
   use parameters
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of columns (dihedrals)
   integer NumSnapIni                                      !Initial number of snapshots
   integer SnapInterval                                    !Snapshot interval
   integer NumInterval                                     !Number of Snap interval
   integer NumSnapTot                                      !Total number of snapshots considered
   integer,intent(in out)::N(NumSnapTot,NumCol)            !Data Matrix
   logical s1calc
   logical shuffling
   logical lowmem

   integer NeigList(NumCol,NumCol)                         !Neighbors Lists. The i-row contains
!the list Li={Ai,...} (see ref.(3))
   integer XAB(2)

   integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
   integer NumSnap                                         !Number of snapshots in the current CALC
   integer NumState                                        !
   real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values
   real(DP),intent(out)::S1(NumCol,NumInterval)            ! Array of Entropy Values
   real(DP),intent(out)::S2(NumCol,NumCol,NumInterval)     ! Array of Entropy Values
   integer i,j,k,l                                         !Counters
   real(DP) CutOff                                         !CutOff

   integer,dimension (:),allocatable :: RandRow(:)         ! Randomization
   integer,dimension (:,:),allocatable :: NewN(:,:)        ! Data matrix columns after random reordering
   integer,dimension (:),allocatable :: CountState
   real(DP),dimension (:,:),allocatable :: ENT1            ! First order entropy
   real(DP),dimension (:,:),allocatable :: ENT2            ! Secont order entropy contribution
   real(DP),dimension (:),allocatable :: ENT2_1            !          Original
   real(DP),dimension (:),allocatable :: ENT2_2            !          Shuffled
   real(DP),dimension (:),allocatable :: ENT1_2            !          Shuffled

   integer idmax
   character*8 Estimator                                   !Estimator

   !-----------------------------------------------------------------------------------

   !Initial values
   Entropy=0d0
   !
   !     Checking maximum ID
   !
   idmax=0
   do i=1,NumSnapTot
      if (maxval(N(i,:)) .gt. idmax) idmax=maxval(N(i,:))
   enddo
   !
   !-Allocating
   !
   allocate(ENT1(NumCol,NumInterval))
   allocate(CountState(NumSnapTot))
   S1=0.0d0
   ENT1=0.0d0
   CountState=0

   !-Computing the marginal entropies

   ! We use two simple OMP strategies. If lowmem=.false. then the outer
   ! loops over data columns implemented in this subroutine are parallelized
   ! These loops call a serial ENTRO_QSORT routine
   ! Alternatively, OMP pragmas are used in the ENTRO_OMP_QSORT routine. The
   ! first option is more efficient , but it has a larger RAM 
   ! impact. Eventually, if RAM swapping/depeletion is observed 
   ! (small RAM or very large dataset) lowmem may help.


   if ( .not. lowmem  ) then

!$omp parallel default(none), private(j),&
!$omp shared(idmax,N,NumSnapIni,SnapInterval,NumINterval,NumSnapTot,NumCol,ENT1)
!$omp do schedule(dynamic)
      do j=1,NumCol
         CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,j),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1(j,:))
      enddo
!$omp end do
!$omp end parallel

   else
      do j=1,NumCol
         CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,j),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1(j,:),NumState,CountState)
      enddo
   endif
   S1=ENT1

   if ( s1calc ) then
      do i=1,NumCol
         Entropy=Entropy+ENT1(i,:)
      enddo
      deallocate(ENT1)
      deallocate(CountState)
      return
   endif
   !
   !   Second order
   !
   allocate(ENT2(NumCol,NumInterval))
   allocate(ENT2_1(NumInterval))
   allocate(ENT2_2(NumInterval))
   allocate(ENT1_2(NumInterval))
   allocate(RandRow(NumSnapTot))
   allocate(NewN(NumSnapTot,2))
   do i=1,NumSnapTot
      RandRow(i)=i
   enddo
   S2=0.0d0
   ENT2=0.0d0

   if ( .not. lowmem ) then 

!$omp parallel default(none), private(i,j,l,XAB,ENT1_2,ENT2_1,ENT2_2,NewN,randrow)  &
!$omp shared(idmax,N,NumSnapIni,SnapInterval,NumINterval,NumSnapTot,NumCol,NumNeig,NeigList,shuffling,S2,ENT1,ENT2)
!$omp do schedule(dynamic)

   do i=1,NumCol
      NewN=0
      ENT1_2=0.0d0
      XAB(1)=i
      if ( shuffling )  then
         call Randomize_Row(RandRow,NumSnapTot)
         do l=1,NumSnapTot
            NewN(l,1)=N(RandRow(l),XAB(1))
         enddo
         CALL ENTRO_QSORT(idmax,NewN(:,1),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1_2)
      endif
      do j=1,NumNeig(i)
         XAB(2)=NeigList(i,j)
         ENT2_1=0.d0
         ENT2_2=0.d0
         !--------------------------------------------------! S2_AB
         CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,XAB),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,2,ENT2_1)

         if ( shuffling ) then

            NewN(:,2)=N(:,XAB(2))

            !--------------------------------------------------! S2_AB (discount
            !only the shuffled correlation contribution)
            CALL ENTRO_QSORT(idmax,NewN,   &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,2,ENT2_2)

            S2(XAB(1),XAB(2),:)=( ENT2_1 - ENT1(XAB(1),:) ) - ( ENT2_2 - ENT1_2 )
            S2(XAB(2),XAB(1),:)=S2(XAB(1),XAB(2),:)
            ENT2(XAB(1),:)=ENT2(XAB(1),:) + S2(XAB(1),XAB(2),:)

         else

            ENT2_2 = ENT1(XAB(1),:) + ENT1(XAB(2),:)

            S2(XAB(1),XAB(2),:)=ENT2_1-ENT2_2
            S2(XAB(2),XAB(1),:)=S2(XAB(1),XAB(2),:)
            ENT2(XAB(1),:)=ENT2(XAB(1),:) + S2(XAB(1),XAB(2),:)

         endif


      enddo
   enddo

!$omp end do
!$omp end parallel

   else

   do i=1,NumCol
      NewN=0
      ENT1_2=0.0d0
      XAB(1)=i
      if ( shuffling )  then
         call Randomize_Row(RandRow,NumSnapTot)
         do l=1,NumSnapTot
            NewN(l,1)=N(RandRow(l),XAB(1))
         enddo
         CALL ENTRO_OMP_QSORT(idmax,NewN(:,1),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1_2,NumState,CountState)
      endif
      do j=1,NumNeig(i)
         XAB(2)=NeigList(i,j)
         ENT2_1=0.d0
         ENT2_2=0.d0
         !--------------------------------------------------! S2_AB
         CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,XAB),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,2,ENT2_1,NumState,CountState)

         if ( shuffling ) then

            NewN(:,2)=N(:,XAB(2))

            !--------------------------------------------------! S2_AB (discount
            !only the shuffled correlation contribution)
            CALL ENTRO_OMP_QSORT(idmax,NewN,   &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,2,ENT2_2,NumState,CountState)

            S2(XAB(1),XAB(2),:)=( ENT2_1 - ENT1(XAB(1),:) ) - ( ENT2_2 - ENT1_2 )
            S2(XAB(2),XAB(1),:)=S2(XAB(1),XAB(2),:)
            ENT2(XAB(1),:)=ENT2(XAB(1),:) + S2(XAB(1),XAB(2),:)

         else

            ENT2_2 = ENT1(XAB(1),:) + ENT1(XAB(2),:)

            S2(XAB(1),XAB(2),:)=ENT2_1-ENT2_2
            S2(XAB(2),XAB(1),:)=S2(XAB(1),XAB(2),:)
            ENT2(XAB(1),:)=ENT2(XAB(1),:) + S2(XAB(1),XAB(2),:)

         endif

      enddo
   enddo

   endif

   do i=1,NumCol
      Entropy=Entropy + ENT1(i,:) + ENT2(i,:)
   enddo

   deallocate(ENT1)
   deallocate(ENT2)
   deallocate(ENT2_1)
   deallocate(ENT2_2)
   deallocate(ENT1_2)
   deallocate(CountState)
   deallocate(RandRow)
   deallocate(NewN)
   return
END SUBROUTINE S1_S2_calc
!-----------------------------------------------------------------------------------------


!*****************************************************************************************
SUBROUTINE CCMLA_CALC(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot     &
   ,NumCol,NeigList,NumNeig   &
   ,Entropy,CutOff,Estimator,verbose,idcol)
!*****************************************************************************************
!As the name implies, this subroutine computes the CCMLA entropy
!using the given cutoff
!
! This version of the CCMLA routine can produce a lot of output, useful to 
! assess the statistical robustness of the results. It is  less efficient,
! however, than the CCMLA_CALC_OMP routine (see below), which should be
! used preferably. However, it uses also less RAM so that it may be the right
! choice for very big datasets (-lowmem option)
!
!-----------------------------------------------------------------------------------------
   use parameters
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of columns (dihedrals)
   integer NumSnapIni                                      !Initial number of snapshots
   integer SnapInterval                                    !Snapshot interval
   integer NumInterval                                     !Number of Snap interval
   integer NumSnapTot                                      !Total number of snapshots considered
   integer,intent(in out)::N(NumSnapTot,NumCol)            !Data Matrix
   integer,intent(in )::idcol(NumCol)

   integer,dimension (:,:),allocatable :: NewN(:,:) !The data matrix after random reordering
   !of the elements of its columns.

   integer NeigList(NumCol,NumCol)                          !Neighbors Lists. The i-row contains
   !the list Li={Ai,...} (see ref.(3))

   integer X(NumCol)                                       !Temporal variable where is saved when needed
   !one of the lists Li={Ai,...} (see ref.(3)

   integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
   integer NumSnap                                         !Number of snapshots in the current CALC
   logical verbose                                       ! Print out ccmla data ?
   real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values
   integer i,j,k,l,kmax                                             !Counters
   real(DP) CutOff                                         !CutOff

   integer,dimension (:),allocatable ::  CountState
   integer NumState_A, NumState_B
   real(DP) cmean_A,cvar_A, csd_A, fmax , sterm , pterm, sapprox, fhist
   real(DP) cmean_B,cvar_B, csd_B
   integer  cmax_A,cmin_A,c
   integer  cmax_B,cmin_B
   integer,dimension (:),allocatable ::  freq_A
   integer,dimension (:),allocatable ::  freq_B

   integer NumState_A_rand, NumState_B_rand
   real(DP) cmean_A_rand,cvar_A_rand, csd_A_rand
   real(DP) cmean_B_rand,cvar_B_rand, csd_B_rand
   integer  cmax_A_rand,cmin_A_rand
   integer  cmax_B_rand,cmin_B_rand
   integer,dimension (:),allocatable ::  freq_A_rand
   integer,dimension (:),allocatable ::  freq_B_rand

   real(DP),dimension (:),allocatable :: ENT1_1            !S(Li) see ref(3) for notations
   real(DP),dimension (:),allocatable :: ENT1_2            !S'(Li) see ref(3) for notations
   real(DP),dimension (:),allocatable :: ENT2_1            !S(Li-Ai) see ref(3) for notations
   real(DP),dimension (:),allocatable :: ENT2_2            !S'(Li-Ai) see ref(3) for notations
   real(DP),dimension (:,:),allocatable :: ENT1            !ENT1(i)=S(Li)-S'(Li)
   real(DP),dimension (:,:),allocatable :: ENT2            !ENT2(i)=S(Li-Ai)-S'(Li-Ai)
   real(DP),dimension (:),allocatable :: ENT1_SHUF

   integer,dimension (:),allocatable :: RandRow(:)         !A vector where the components are selected
   !randomly without replacement from {1,...,NumSnap}

   real(DP),dimension (:,:),allocatable :: S1              !Matrix of marginal entropies
   integer iprevious,Limit,ii,idmax                        !Auxiliary integer variables
   character*8 Estimator                                   !Estimator
   logical found                                         !Auxiliary logical variables

   !in function "ran"
   !-----------------------------------------------------------------------------------

   !Initial values
   Entropy=0d0
   iprevious=0
   found=.false.
   fhist=25.0d0
   if ( verbose ) then
      write(*,'(''==================== '')')
      write(*,'(''CCMLA verbose output '')')
      write(*,'(''==================== '')')
   endif
!
!     Checking maximum ID
!
   idmax=0
   do i=1,NumSnapTot
      if (maxval(N(i,:)) .gt. idmax) idmax=maxval(N(i,:))
   enddo
!
   !-Allocating
   allocate(ENT1(NumCol,NumInterval))
   allocate(ENT2(NumCol,NumInterval))
   allocate(ENT1_1(NumInterval))
   allocate(ENT1_2(NumInterval))
   allocate(ENT2_1(NumInterval))
   allocate(ENT2_2(NumInterval))
   allocate(ENT1_SHUF(NumInterval))
   allocate(S1(NumCol,NumInterval))
   allocate(RandRow(NumSnapTot))
   allocate(NewN(NumSnapTot,NumCol))
   allocate(CountState(NumSnapTot))

   do i=1,NumSnapTot
      RandRow(i)=i
   enddo

   !
   !-Obtaining NewN : A single shuffling operation comprising all the snapshots
   ! is performed. This is computationally very efficient. For obtaining
   ! correlation plots, it is statistically robust given that bias correction in the entropy
   ! estimations for the consecutive intervals incorporates both shuffling and
   ! scrambling by data exchange among subintervals. There is a caveat,
   ! however, the convergence plot of the CC-MLA entropies does not assess the
   ! the convergence quality of each consecutive subinterval, but of the whole
   ! dataset.  Anyway, this is what really matters and it is a more stringent
   ! convergence test. Note also that the final 
   ! entropy estimation obtained by this procedure is perfectly equivalent
   ! to that obtained by consecutive shuffling operations
   !
   !
   do j=1,NumCol
      call Randomize_Row(RandRow,NumSnapTot)
      do i=1,NumSnapTot
         NewN(i,j)=N(RandRow(i),j)
      enddo
   enddo

   S1=0.0d0
   ENT1=0.0d0
   ENT2=0.0d0

   !-Computing the marginal entropies
   do j=1,NumCol
      CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,j),   &
         NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,S1(j,:),k,CountState)
   enddo

   do i=1,NumCol
      ENT1_1=0.d0
      ENT1_2=0.d0
      ENT2_1=0.d0
      ENT2_2=0.d0
      ENT1_SHUF=0.0d0
      ENT1(i,:)=0.d0
      ENT2(i,:)=0.d0

      if ( NumNeig(i) .ge. 1 ) then

         CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,i),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1_SHUF,k,CountState)

         ! Printing List of Neigbohrs
         if ( verbose ) then
            write(*,'(''COL='',I3,'' Neighbohrs='',512(I4))') i,(NeigList(i,j),j=1,NumNeig(i))
            write(*,'(''IDCOL='',I3,'' Neighbohrs='',512(I4))') idcol(i),(idcol(NeigList(i,j)),j=1,NumNeig(i))
         endif

         do j=1,NumNeig(i)
            X(j)=NeigList(i,j)
         enddo
         X(NumNeig(i)+1)=i
         !--------------------------------------------------!Computing S(Li) and S'(Li)
         CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i)+1)),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,(NumNeig(i)+1),ENT1_1,NumState_A,CountState)

         if ( verbose ) then
            ! Printing Some Statistical Info of the Multivariate Counting
            cmean_A=0.0d0
            do k=1,NumState_A
               cmean_A=cmean_A+real(CountState(k),kind=DP)
            enddo
            cvar_A=0.0d0
            cmean_A=cmean_A/real(NumState_A,kind=DP)
            do k=1,NumState_A
               cvar_A=cvar_A+(real(CountState(k),kind=DP)-cmean_A)**2
            enddo
            cvar_A=cvar_A/real(NumState_A,kind=DP)
            csd_A= sqrt( cvar_A )
            cmax_A=maxval(CountState(1:NumState_A))
            cmin_A=minval(CountState(1:NumState_A))
            write(*,'(''         NumState_A='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
               NumState_A, cmean_A, csd_A, cmax_A,cmin_A
            fmax=fhist*(log10(real(NumSnapTot,kind=DP)))
            kmax=int(fmax)+1
            allocate (freq_A(kmax))
            allocate (freq_B(kmax))
            allocate (freq_A_rand(kmax))
            allocate (freq_B_rand(kmax))
            freq_A=0
            freq_B=0
            freq_A_rand=0
            freq_B_rand=0
            do k=1,NumState_A
               c=CountState(k)
               l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
               freq_A(l)=freq_A(l)+1
            enddo
         endif


         CALL ENTRO_OMP_QSORT(idmax,NewN(1:NumSnapTot,X(1:NumNeig(i)+1)), &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,(NumNeig(i)+1),ENT1_2,NumState_A_rand,CountState)
         if ( verbose ) then
            cmean_A_rand=0.0d0
            do k=1,NumState_A_rand
               cmean_A_rand=cmean_A_rand+real(CountState(k),kind=DP)
            enddo
            cvar_A_rand=0.0d0
            cmean_A_rand=cmean_A_rand/real(NumState_A_rand,kind=DP)
            do k=1,NumState_A_rand
               cvar_A_rand=cvar_A_rand+(real(CountState(k),kind=DP)-cmean_A_rand)**2
            enddo
            cvar_A_rand=cvar_A_rand/real(NumState_A_rand,kind=DP)
            csd_A_rand= sqrt( cvar_A_rand )
            cmax_A_rand=maxval(CountState(1:NumState_A_rand))
            cmin_A_rand=minval(CountState(1:NumState_A_rand))
            write(*,'(''         NumState_A_rand='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
               NumState_A_rand, cmean_A_rand, csd_A_rand, cmax_A_rand,cmin_A_rand
            do k=1,NumState_A_rand
               c=CountState(k)
               l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
               freq_A_rand(l)=freq_A_rand(l)+1
            enddo
         endif


         ENT1(i,:)=ENT1_1-ENT1_2 - ( S1(i,:) - ENT1_SHUF )
         if ((i.ne.NumCol).and.(NumNeig(i).ne.0)) then
            !--------------------------------------------------!Computing S(Li-Ai) and S'(Li-Ai)
            CALL ENTRO_OMP_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i))), &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumNeig(i),ENT2_1,NumState_B,CountState)
            if ( verbose ) then
               ! Printing Some Statistical Info of the Multivariate Counting
               cmean_B=0.0d0
               do k=1,NumState_B
                  cmean_B=cmean_B+real(CountState(k),kind=DP)
               enddo
               cvar_B=0.0d0
               cmean_B=cmean_B/real(NumState_B,kind=DP)
               do k=1,NumState_B
                  cvar_B=cvar_B+(real(CountState(k),kind=DP)-cmean_B)**2
               enddo
               cvar_B=cvar_B/real(NumState_B,kind=DP)
               csd_B= sqrt( cvar_B )
               cmax_B=maxval(CountState(1:NumState_B))
               cmin_B=minval(CountState(1:NumState_B))
               write(*,'(''         NumState_B='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
                  NumState_B, cmean_B, csd_B, cmax_B,cmin_B
               freq_B=0
               do k=1,NumState_B
                  c=CountState(k)
                  l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
                  freq_B(l)=freq_B(l)+1
               enddo
            endif

            CALL ENTRO_OMP_QSORT(idmax,NewN(1:NumSnapTot,X(1:NumNeig(i))),&
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumNeig(i),ENT2_2,NumState_B_rand,CountState)

            if ( verbose ) then
               cmean_B_rand=0.0d0
               do k=1,NumState_B_rand
                  cmean_B_rand=cmean_B_rand+real(CountState(k),kind=DP)
               enddo
               cvar_B_rand=0.0d0
               cmean_B_rand=cmean_B_rand/real(NumState_B_rand,kind=DP)
               do k=1,NumState_B_rand
                  cvar_B_rand=cvar_B_rand+(real(CountState(k),kind=DP)-cmean_B_rand)**2
               enddo
               cvar_B_rand=cvar_B_rand/real(NumState_B_rand,kind=DP)
               csd_B_rand= sqrt( cvar_B_rand )
               cmax_B_rand=maxval(CountState(1:NumState_B_rand))
               cmin_B_rand=minval(CountState(1:NumState_B_rand))
               write(*,'(''         NumState_B_rand='',I8,'' Mean/SD/Max/Min Pop='',2E16.8,2I10)')  &
                  NumState_B_rand, cmean_B_rand, csd_B_rand, cmax_B_rand,cmin_B_rand
               do k=1,NumState_B_rand
                  c=CountState(k)
                  l=  kmax -  int ( real(kmax-1,kind=DP) * ( ( fmax -  fhist*log10(real(c,kind=DP)) )  / fmax ) )
                  freq_B_rand(l)=freq_B_rand(l)+1
               enddo
            endif

            ENT2(i,:)=ENT2_1-ENT2_2
         else
            ENT2(i,:)=0.d0
         endif

         if ( verbose ) then
            write(*,'(''         Correlation_Terms_ENT1/ENT2/ENT1-ENT2/Sapprox/='',2F12.4,1X,2F9.4)') &
               ENT1(i,NumInterval),ENT2(i,NumInterval),ENT1(i,NumInterval)-ENT2(i,NumInterval),sapprox
            write(*,'(''         log10(Count)    Count     Freq_A    Freq_B    Freq_A_rand   Freq_B_rand    S_approx '')')
            sapprox=0.d0
            do  k=1,kmax
               if ( freq_A(k)+freq_B(k)+freq_A_rand(k)+freq_B_rand(k) .gt. 0 ) then
                  pterm= ( 10.d0**( real(k,kind=DP)/fhist ) ) / real(NumSnapTot,kind=DP)
                  sterm= - real(freq_A(k) - freq_A_rand(k) - (  freq_B(k) - freq_B_rand(k)),kind=DP)*R*pterm*log(pterm)
                  write(*,'(''         '',F10.6,E16.8,4I10,F12.4)') &
                     real(k,kind=DP)/fhist, 10.d0**( real(k,kind=DP)/fhist ), &
                     freq_A(k), freq_B(k) , freq_A_rand(k) , freq_B_rand(k),  sterm
                  sapprox=sapprox+sterm
               endif
            enddo
            deallocate(freq_A)
            deallocate(freq_B)
            deallocate(freq_A_rand)
            deallocate(freq_B_rand)

         endif

      endif

      if(((10*i/NumCol).gt.iprevious).and.(verbose)) then
         write(*,*) 10*(iprevious+1),"%"
         iprevious=10*i/NumCol
      endif

   enddo

   do i=1,NumCol
      Entropy=Entropy+S1(i,:)+(ENT1(i,:)-ENT2(i,:))                !Finally, computing the CC-MLA Entropy
   enddo

   deallocate(ENT1)
   deallocate(ENT2)
   deallocate(ENT1_1)
   deallocate(ENT1_2)
   deallocate(ENT2_1)
   deallocate(ENT2_2)
   deallocate(S1)
   deallocate(RandRow)
   deallocate(NewN)
   deallocate(CountState)
   return
END SUBROUTINE CCMLA_CALC
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
SUBROUTINE CCMLA_CALC_OMP(N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot     &
   ,NumCol,NeigList,NumNeig,Entropy,CutOff)
!*****************************************************************************************
!As the name implies, this subroutine computes the CCMLA entropy
!using the given cutoff
!-----------------------------------------------------------------------------------------
   use parameters
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of columns (dihedrals)
   integer NumSnapIni                                      !Initial number of snapshots
   integer SnapInterval                                    !Snapshot interval
   integer NumInterval                                     !Number of Snap interval
   integer NumSnapTot                                      !Total number of snapshots considered
   integer,intent(in out)::N(NumSnapTot,NumCol)            !Data Matrix

   integer NeigList(NumCol,NumCol)                          !Neighbors Lists. The i-row contains
   !the list Li={Ai,...} (see ref.(3))

   integer X(NumCol)                                       !Temporal variable where is saved when needed
   !one of the lists Li={Ai,...} (see ref.(3)

   integer NumNeig(NumCol)                                 !Number of Neighbors of the i-element(Ai)
   integer NumSnap                                         !Number of snapshots in the current CALC
   real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values
   integer i,j,k,l,kmax                                             !Counters
   real(DP) CutOff                                         !CutOff

   real(DP),dimension (:),allocatable :: ENT1_1            !S(Li) see ref(3) for notations
   real(DP),dimension (:),allocatable :: ENT1_2            !S'(Li) see ref(3) for notations
   real(DP),dimension (:),allocatable :: ENT2_1            !S(Li-Ai) see ref(3) for notations
   real(DP),dimension (:),allocatable :: ENT2_2            !S'(Li-Ai) see ref(3) for notations
   real(DP),dimension (:,:),allocatable :: ENT1            !ENT1(i)=S(Li)-S'(Li)
   real(DP),dimension (:,:),allocatable :: ENT2            !ENT2(i)=S(Li-Ai)-S'(Li-Ai)
   real(DP),dimension (:),allocatable :: ENT1_SHUF
   integer,dimension (:),allocatable :: tmpN

   integer,dimension (:),allocatable :: RandRow(:)         !A vector where the components are selected
   !randomly without replacement from {1,...,NumSnap}

   real(DP),dimension (:,:),allocatable :: S1              !Matrix of marginal entropies
   integer ii,idmax                                        !Auxiliary integer variables

   !in function "ran"
   !-----------------------------------------------------------------------------------

   !Initial values
   Entropy=0d0
!
!     Checking maximum ID
!
   idmax=0
   do i=1,NumSnapTot
      if (maxval(N(i,:)) .gt. idmax) idmax=maxval(N(i,:))
   enddo
!
   !-Allocating
   allocate(ENT1(NumCol,NumInterval))
   allocate(ENT2(NumCol,NumInterval))
   allocate(ENT1_1(NumInterval))
   allocate(ENT1_2(NumInterval))
   allocate(ENT2_1(NumInterval))
   allocate(ENT2_2(NumInterval))
   allocate(ENT1_SHUF(NumInterval))
   allocate(S1(NumCol,NumInterval))
   allocate(RandRow(NumSnapTot))
   allocate(tmpN(NumSnapTot))

   do i=1,NumSnapTot
      RandRow(i)=i
   enddo

   !
   ! A single shuffling operation comprising all the snapshots
   ! is performed. This is computationally very efficient. For obtaining
   ! correlation plots, it is statistically robust given that bias correction in the entropy
   ! estimations for the consecutive intervals incorporates both shuffling and
   ! scrambling by data exchange among subintervals. There is a caveat,
   ! however, the convergence plot of the CC-MLA entropies does not assess the
   ! the convergence quality of each consecutive subinterval, but of the whole
   ! dataset.  Anyway, this is what really matters and it is a more stringent
   ! convergence test. Note also that the final 
   ! entropy estimation obtained by this procedure is perfectly equivalent
   ! to that obtained by consecutive shuffling operations
   !

   S1=0.0d0
   ENT1=0.0d0
   ENT2=0.0d0

!-Computing the marginal entropies
!$omp parallel default(none), private(j),&
!$omp shared(idmax,N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumCol,S1)
!$omp do schedule(dynamic)
   do j=1,NumCol
      CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,j),   &
         NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,S1(j,:))
   enddo
!$omp end do
!$omp end parallel

!$omp parallel default(none),private(i,j,X,ENT1_1,ENT2_1,ENT1_SHUF)  &
!$omp shared(idmax,N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumCol,NumNeig,NeigList,S1,ENT1,ENT2)
!$omp do schedule(dynamic)

   do i=1,NumCol
      ENT1_1=0.d0
      ENT2_1=0.d0
      ENT1_SHUF=0.0d0
      if ( NumNeig(i) .ge. 1 ) then
         CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,i),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,1,ENT1_SHUF)
         do j=1,NumNeig(i)
            X(j)=NeigList(i,j)
         enddo
         X(NumNeig(i)+1)=i
         !--------------------------------------------------!Computing S(Li) and S'(Li)
         CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i)+1)),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,(NumNeig(i)+1),ENT1_1)
         ENT1(i,:)=ENT1_1 - ( S1(i,:) - ENT1_SHUF )
         if ((i.ne.NumCol).and.(NumNeig(i).ne.0)) then
            !--------------------------------------------------!Computing S(Li-Ai) and S'(Li-Ai)
            CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i))), &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumNeig(i),ENT2_1)
            ENT2(i,:)=ENT2_1
         else
            ENT2(i,:)=0.d0
         endif
      endif
   enddo

!$omp end do
!$omp end parallel

! To avoid relicating tmpN, this loop is not parallelized
   do j=1,NumCol
      call Randomize_Row(RandRow,NumSnapTot)
      do i=1,NumSnapTot
         tmpN(i)=N(RandRow(i),j)
      enddo
      do i=1,NumSnapTot
         N(i,j)=tmpN(i)
      enddo
   enddo

!$omp parallel default(none),private(i,j,X,ENT1_2,ENT2_2)  &
!$omp shared(idmax,N,NumSnapIni,SnapInterval,NumINterval,NumSnapTot,NumCol,NumNeig,NeigList,ENT1,ENT2)
!$omp do schedule(dynamic)

   do i=1,NumCol
      ENT1_2=0.d0
      ENT2_2=0.d0
      if ( NumNeig(i) .ge. 1 ) then
         do j=1,NumNeig(i)
            X(j)=NeigList(i,j)
         enddo
         X(NumNeig(i)+1)=i
         !--------------------------------------------------!Computing S(Li) and S'(Li)
         CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i)+1)),   &
            NumSnapIni,SnapInterval,NumInterval,NumSnapTot,(NumNeig(i)+1),ENT1_2)

         ENT1(i,:)= ENT1(i,:) - ENT1_2 
         if ((i.ne.NumCol).and.(NumNeig(i).ne.0)) then
            !--------------------------------------------------!Computing S(Li-Ai) and S'(Li-Ai)
            CALL ENTRO_QSORT(idmax,N(1:NumSnapTot,X(1:NumNeig(i))), &
               NumSnapIni,SnapInterval,NumInterval,NumSnapTot,NumNeig(i),ENT2_2)

            ENT2(i,:)=ENT2(i,:)-ENT2_2
         endif
      endif
   enddo

!$omp end do
!$omp end parallel

   do i=1,NumCol
      Entropy=Entropy+S1(i,:)+(ENT1(i,:)-ENT2(i,:))    
   enddo

   deallocate(ENT1)
   deallocate(ENT2)
   deallocate(ENT1_1)
   deallocate(ENT1_2)
   deallocate(ENT2_1)
   deallocate(ENT2_2)
   deallocate(S1)
   deallocate(RandRow)
   deallocate(tmpN)
   return
END SUBROUTINE CCMLA_CALC_OMP
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
SUBROUTINE ENTRO_OMP_QSORT(idmax,N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,&
   NumCol,Entropy,NumState,CountState)
!*****************************************************************************************
!  This subroutine computes entropy values.
!
!  It transforms the N(NumSnapIni,NumCol) matrix describing the evolution of
!  discretized dihedral angles along NumSnapIni MD snapshots into one (or more)
!  one-dimensional arrays of NumSnapini (large) integer numbers. This is
!  done as follows:
!
!  N(i,:) = sequence of integer numbers labelling the conformational states
!  of a dihedral set at a the i-snapshot. The values of these integer
!  numbers are <= idmax (Typically idmax=3)
!
!  N(I,:) defines an base-idmax number which is transformed into an idcode
!  base-10 integer number by means of dot products. Note that idcode is
!  stored using kind=16 integer mode. If NumCol is larger than
!  code_length then N(i,:) is splitted into smaller segments and
!  several idcode identifiers are generated
!
!  Using a parallel recursive implementation of the quicksort algorithm,
!  the master idcode array is sorted what allows to identify the different conformational
!  states populated by the NumCol dihedrals along the MD trajectory and
!  to determine their relative abundances.
!
!  Entropies are calculated for NumInterval segments of the trajectory.
!  Each interval has  NumSnap=NumSnap+(I-1)*SnapInterval snapshots where
!  I=1,NumInterval
!
!-----------------------------------------------------------------------------------------
   use parameters
   use sort
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of columns (dihedrals)
   integer NumSnapIni                                      !Initial number of snapshots
   integer SnapInterval                                    !Snapshot interval
   integer NumInterval                                     !Number of Snap interval
   integer NumSnapTot                                      !Total number of snapshots considered
   integer NumSnap                                         !Number of snapshots in the current CALC
   integer NumState                                        !Number of Detected Conformational States
   integer idmax                                           !Maximum integer value in N
   integer NumSnap0
   integer  N(NumSnapTot,NumCol)                           ! Input Matrix
   real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values
   integer ,intent(out)::CountState(NumSnapTot)            ! Array of Population data for Conformational States
   real(DP) p                                              ! Probability (relative frequency)
   integer i,j,k,c,l,ii,idummy                             !  Auxiliary index variables
   integer numid,ifirst,ilast,code_length
   integer,dimension (:),allocatable :: indx               ! Index of
   integer,dimension (:),allocatable :: iconf              ! Aray collecting the abundances of conformational states
   integer(kind=16) nbase
   integer(kind=16),dimension (:),allocatable :: basepower(:)
   integer(kind=16),dimension (:,:),allocatable :: idcode(:,:)
   integer(kind=16),dimension (:),allocatable :: idcode_temp(:)
   logical lconf
!
!     Determine the number of ids required for each row in MATRIX
!
   code_length=30
   numid=NumCol/code_length+1
!
!     Precomputing the vector for BASE_nbase ---> BASE_10 conversion
!
   nbase=int(idmax+1,kind=16)
   allocate(basepower(code_length))
   do i=1,code_length
      basepower(i)=nbase**(int(i-1,kind=16))
   enddo
!
!     Compute the integer ID codes for each row
!
   allocate(idcode(NumSnapTot,numid))
   ifirst=1
   ilast=code_length

   do i=1,numid
      if ( ilast .gt. NumCol ) ilast=NumCol
      j=ilast-ifirst+1
      !$omp parallel default(none), private(k),&
      !$omp shared(numsnaptot,idcode,N,basepower,ifirst,ilast,i,j)
      !$omp do schedule(static)
      do k=1,NumSnapTot
         idcode(k,i)=  &
            dot_product(int(N(k,ifirst:ilast),kind=16),basepower(1:j))
      enddo
      !$omp end do
      !$omp end parallel
      ifirst=ilast+1
      ilast=ilast+code_length
!
   enddo
!
!     Sorting ID codes
!
   allocate (indx(NumSnapTot))
   allocate (idcode_temp(NumSnapTot))
   do i=1,NumSnapTot
      idcode_temp(i)=idcode(i,1)
      indx(i)=i
   enddo
   call MTSort(idcode_temp,indx,NumSnapTot,"Ascending")
!
!     counting conformational states
!
   allocate (iconf(NumSnapTot))
   iconf(indx(1))=1
   c=1
   do k=2,NumSnapTot
      i=indx(k)
      j=indx(k-1)
      lconf=.true.
      do l=1,numid
         lconf=lconf .and.  ( idcode(i,l) .eq. idcode(j,l) )
      enddo
      if ( .not. lconf ) c=c+1
      iconf(i)=c
   enddo
!
   CountState=0
!
!     computing ML entropy values per interval
!
   NumSnap0=1
   do ii=1,NumInterval
      Entropy(ii)=0.0d0
      NumSnap=NumSnapIni+(ii-1)*SnapInterval
      do i=NumSnap0,NumSnap
         CountState (  iconf(i)  ) =  CountState (  iconf(i)  ) + 1
      enddo
      do k=1,c
         p=real(CountState(k),kind=8)/real(NumSnap,kind=8)
         if ( p .gt. 0.0d0 ) Entropy(ii)=Entropy(ii)-R*p*log(p)
      enddo
      NumSnap0=NumSnap+1
   enddo
!
   NumState=c
!
   deallocate (iconf)
   deallocate (indx)
   deallocate (basepower)
   deallocate (idcode)
   deallocate (idcode_temp)

   return
END SUBROUTINE ENTRO_OMP_QSORT
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
SUBROUTINE ENTRO_QSORT(idmax,N,NumSnapIni,SnapInterval,NumInterval,NumSnapTot,&
   NumCol,Entropy)
!*****************************************************************************************
!  This subroutine computes entropy values.
!
!  It transforms the N(NumSnapIni,NumCol) matrix describing the evolution of
!  discretized dihedral angles along NumSnapIni MD snapshots into one (or more)
!  one-dimensional arrays of NumSnapini (large) integer numbers. This is
!  done as follows:
!
!  N(i,:) = sequence of integer numbers labelling the conformational states
!  of a dihedral set at a the i-snapshot. The values of these integer
!  numbers are <= idmax (Typically idmax=3)
!
!  N(I,:) defines an base-idmax number which is transformed into an idcode
!  base-10 integer number by means of dot products. Note that idcode is
!  stored using kind=16 integer mode. If NumCol is larger than
!  code_length then N(i,:) is splitted into smaller segments and
!  several idcode identifiers are generated
!
!  Using the quicksort algorithm,  the master idcode array is sorted what
!  allows to identify the different conformational
!  states populated by the NumCol dihedrals along the MD trajectory and
!  to determine their relative abundances.
!
!  Entropies are calculated for NumInterval segments of the trajectory.
!  Each interval has  NumSnap=NumSnap+(I-1)*SnapInterval snapshots where
!  I=1,NumInterval
!
!-----------------------------------------------------------------------------------------
   use parameters
   use sort_serial
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of columns (dihedrals)
   integer NumSnapIni                                      !Initial number of snapshots
   integer SnapInterval                                    !Snapshot interval
   integer NumInterval                                     !Number of Snap interval
   integer NumSnapTot                                      !Total number of snapshots considered
   integer NumSnap                                         !Number of snapshots in the current CALC
   integer NumState                                        !Number of Detected Conformational States
   integer idmax                                           !Maximum integer value in N
   integer NumSnap0
   integer  N(NumSnapTot,NumCol)                           ! Input Matrix
   real(DP),intent(out)::Entropy(NumInterval)              ! Array of Entropy Values
   real(DP) p                                              ! Probability (relative frequency)
   integer i,j,k,c,l,ii,idummy                             !  Auxiliary index variables
   integer numid,ifirst,ilast,code_length
   integer,dimension (:),allocatable :: indx               ! Index of
   integer,dimension (:),allocatable :: iconf              ! Aray collecting the abundances of conformational states
   integer(kind=16) nbase
   integer(kind=16),dimension (:),allocatable :: basepower(:)
   integer(kind=16),dimension (:),allocatable :: CountState(:)
   integer(kind=16),dimension (:,:),allocatable :: idcode(:,:)
   integer(kind=16),dimension (:),allocatable :: idcode_temp(:)
   logical lconf
!
!     Determine the number of ids required for each row in MATRIX
!
   code_length=30
   numid=NumCol/code_length+1
!
!     Precomputing the vector for BASE_nbase ---> BASE_10 conversion
!
   nbase=int(idmax+1,kind=16)
   allocate(basepower(code_length))
   do i=1,code_length
      basepower(i)=nbase**(int(i-1,kind=16))
   enddo
!
!     Compute the integer ID codes for each row
!
   allocate(idcode(NumSnapTot,numid))
   ifirst=1
   ilast=code_length

   do i=1,numid
      if ( ilast .gt. NumCol ) ilast=NumCol
      j=ilast-ifirst+1
      do k=1,NumSnapTot
         idcode(k,i)=  &
            dot_product(int(N(k,ifirst:ilast),kind=16),basepower(1:j))
      enddo
      ifirst=ilast+1
      ilast=ilast+code_length
!
   enddo
!
!     Sorting ID codes
!
   allocate (indx(NumSnapTot))
   allocate (idcode_temp(NumSnapTot))
   do i=1,NumSnapTot
      idcode_temp(i)=idcode(i,1)
      indx(i)=i
   enddo
   call quick_sort(idcode_temp,indx)
!
!     counting conformational states
!
   allocate (iconf(NumSnapTot))
   iconf(indx(1))=1
   c=1
   do k=2,NumSnapTot
      i=indx(k)
      j=indx(k-1)
      lconf=.true.
      do l=1,numid
         lconf=lconf .and.  ( idcode(i,l) .eq. idcode(j,l) )
      enddo
      if ( .not. lconf ) c=c+1
      iconf(i)=c
   enddo
!
   allocate (CountState(NumSnapTot))
   CountState=0
!
!     computing ML entropy values per interval
!
   NumSnap0=1
   do ii=1,NumInterval
      Entropy(ii)=0.0d0
      NumSnap=NumSnapIni+(ii-1)*SnapInterval
      do i=NumSnap0,NumSnap
         CountState (  iconf(i)  ) =  CountState (  iconf(i)  ) + 1
      enddo
      do k=1,c
         p=real(CountState(k),kind=8)/real(NumSnap,kind=8)
         if ( p .gt. 0.0d0 ) Entropy(ii)=Entropy(ii)-R*p*log(p)
      enddo
      NumSnap0=NumSnap+1
   enddo
!
   NumState=c
!
   deallocate (iconf)
   deallocate (indx)
   deallocate (basepower)
   deallocate (idcode)
   deallocate (idcode_temp)
   deallocate (CountState)

   return
END SUBROUTINE ENTRO_QSORT
!-----------------------------------------------------------------------------------------


!*****************************************************************************************
SUBROUTINE Get_Best_Ordering(DIST,NumCol,CutOff,lessthan,X,invX)
!*****************************************************************************************
!This subroutine gives through the variable X, the ordering of the torsions that would
!minimize the additional terms.(see ref(3))
!-----------------------------------------------------------------------------------------
   use parameters
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of columns(torsions)
   real(DP) CutOff                                         !Cutoff
   real(DP) DIST(NumCol,NumCol)                            !Distance matrix
   integer, dimension(:), allocatable :: NNeig             !Number of neighbors of the i-elemt
   integer, dimension(:,:), allocatable :: NList           !Neighbors list
   integer, dimension(:), allocatable :: COUNTER           !Counter
   logical, dimension(:), allocatable :: Selected          !Auxiliary logical variable
   logical i_selected,j_selected,found                   !Auxiliary logical variables
   integer i,j,k,c                                         !
   integer X(NumCol)                                       !Output: Vector whose elements indicate the ordering
   !of the columns in MATRIX.dat that would minimize
   !the additional terms

   integer invX(NumCol)                                    !Output: Inverse of X (i.e., invX(X(i))=i for every i)
   logical lessthan
   logical condition
   !-----------------------------------------------------------------------------------

   allocate(Selected(NumCol))
   allocate(NNeig(NumCol))
   allocate(COUNTER(NumCol))
   allocate(NList(NumCol,NumCol))

   c=0

   do i=1,Numcol
      Selected(i)=.false.
   enddo


   do while(c.lt.NumCol)
      do i=1,NumCol
         NNeig(i)=0
      enddo
      do i=1,NumCol
         COUNTER(i)=0
      enddo

      do i=1,NumCol-1
         do j=i+1,NumCol
            if(Selected(i)) exit
            if ( lessthan ) then
               condition=(DIST(i,j)<CutOff)
            else
               condition=(DIST(i,j)>CutOff)
            endif
            if((condition).and.(.not.Selected(j))) then
               NNeig(i)=NNeig(i)+1
               NNeig(j)=NNeig(j)+1
               NList(i,NNeig(i))=j
               NList(j,NNeig(j))=i
            endif
         enddo
      enddo

      do k=1,NumCol
         do i=1,NNeig(k)-1
            do j=i+1,NNeig(k)
               if ( lessthan ) then
                  condition=(DIST(NList(k,i),NList(k,j)) .gt. CutOff )
               else
                  condition=(DIST(NList(k,i),NList(k,j)) .lt. CutOff )
               endif
               if( condition) COUNTER(k)=COUNTER(k)+1
            enddo
         enddo
      enddo

      found=.false.
      do j=0,((NumCol-1)*(NumCol-2)/2)                     !J is just a counter
         do i=1,NumCol
            if((COUNTER(i)==j).and.(.not.Selected(i))) then !
               c=c+1
               Selected(i)=.true.
               X(c)=i
               invX(i)=c
               found=.true.
               exit
            endif
         enddo
         if(found) exit
      enddo
   enddo

   deallocate(Selected)
   deallocate(NNeig)
   deallocate(COUNTER)
   deallocate(NList)

   return

END SUBROUTINE Get_Best_Ordering
!-----------------------------------------------------------------------------------------

!*****************************************************************************************
SUBROUTINE Get_Neighbors_Info(DIST,NumCol,CutOff,lessthan,NeigList,NumNeig)
!*****************************************************************************************
! This subroutine computes the final neighbors list for the given cutoff and the optimal
!ordering
!-----------------------------------------------------------------------------------------
   use parameters
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer, intent(IN):: NumCol                            !Number of Columns(Dihedrals)
   integer NeigList(NumCol,NumCol)                         !Final neighbors list
   integer NumNeig(NumCol)                                 !Number of neighbors of the i-element
   integer i,j,C                                           !Counters
   real(DP),intent(IN)::CutOff                             !Cutoff
   real(DP),intent(IN)::DIST(NumCol,NumCol)                !Distance matrix
   logical lessthan,condition
   !-----------------------------------------------------------------------------------

   !---INITIATION OF THE NUMBER OF NEIGHBORS
   do i=1,NumCol
      NumNeig(i)=0
   enddo
   !---MAKING THE NEIGHBORS LIST
   do i=1,NumCol
      C=0
      do j=i+1,NumCol
         if ( lessthan ) then
            condition=(DIST(i,j).lt.CutOff)
         else
            condition=(DIST(i,j).gt.CutOff)
         endif
         if( condition ) then
            C=C+1
            NeigList(i,C)=j
            NumNeig(i)= NumNeig(i)+1
         endif
      enddo
   enddo
   return
END SUBROUTINE Get_Neighbors_Info
!-----------------------------------------------------------------------------------------



!*****************************************************************************************
SUBROUTINE Read_Options(CutOff,MaxOrder,Method,filedat,filedist,filetable &
   ,fileps2mat,filers2mat,prints2,reads2,fmtDAT,fmtDIST &
   ,NumSnap,NumSnapIni,NumCol,SnapInterval,GivenNumCol,GivenNumSnap,GivenCutoff,verbose &
   ,Reorder,Estimator,MakeCorrection,shuffling,UseCol,TextCol,Lessthan,Framestep &
   ,S2Filt,CutS2F1,CutS2F2,lowmem)
!*****************************************************************************************
!This subroutine reads all the options that can be given to the
!program through the command line
!-----------------------------------------------------------------------------------------
   use parameters
   implicit none
   !-VARIABLE DEFINITIONS--------------------------------------------------------------
   integer NumCol                                          !Number of Columns(Dihedrals) selected in MATRIX.dat
   integer NumSnapIni                                      !Initial number of Snapshots
   integer NumSnapTot                                      !Total number of rows(Snapshots) to be considered
   integer NumSnap                                         !Number of Snapshots used on each CALC
   integer SnapInterval                                    !Gap in snapshots between consecutive calculations (CALCs)
   integer MaxOrder                                        !Maximum order of expansion (MIE, AMIE, ...)

   logical shuffling                                       !Filter false correlation  in S2? (True/False)

   integer Method                                          !Method, the are 3 possible values for this variable:
   ! 1 - MIE
   ! 2 - AMIE
   ! 3 - MLA or CCMLA (Correlation Corrected MLA)
   ! The discrimination between the two options in 3
   ! is done through the "shuffling" variable

   logical Reorder                                         !Change the ordering of the dihedrals
   !in order to minimize the additional terms?
   !(True/False)
   logical  verbose

   real(DP) CutOff                                         !Cutoff
   integer j,i,A,i1,C,k                                    !Counters

   logical MakeCorrection                                  !Eliminate de additional terms up to de given
   !MaxOrder? (True/False)

   logical GivenNumCol                                     !Is the number of columns (NumCol) specified? (True/False)
   logical GivenNumSnap                                    !Is the number of snapshots specified? (True/False)
   logical GivenCutoff                                     !Is the cutoff specified? (True/False)
   logical UseCol                                          !Are columns selected ? (True/False)
   logical Lessthan                                        ! Criteria to use distance cutoff
   logical S2Filt                                          ! Activate S2-based filtering of dihedrals
   logical prints2
   logical reads2
   logical lowmem
   real(DP) CutS2F1, CutS2F2                               ! S2 corr cutoffs

   character*1024 TextCol                                   !Text variable for selected columns
   integer framestep                                       ! Row step for reading MATRIX.dat. Default 1 (i.e, all rows)

   real(DP) RealVar                                        !Auxiliary real variable

   character*12 fmtDAT, fmtDIST

   character*60  filedist                                  !Filename of the distance matrix file
   !Default:reduced_dist_matrix.dat

   character*60  filedat                                   !Filename of the data file (Default: MATRIX.dat).
   !This file contains the discretized evolution
   !of the dihedral angles

   character*60  fileps2mat                                 !Filename of the file where the S2mat is printed
   character*60  filers2mat                                 !Filename of the file where the S2mat is read

   character*60  filetable                                 !Filename of the file where the results are
   !summarized in table form

   integer ios,idummy,iargc                                !Auxiliary integer variables
   character*8  Estimator                                  !Estimator: Max-Likelihood(-ml) or Chao-Shen(-cs)
   character*1024 arg                                      !Dummy character variable
!-----------------------------------------------------------------------------------

!--READING OPTIONS
   C=0
   do i = 1, iargc()
      call getarg(i, arg)
      if((arg.eq.'-c').or.(arg.eq.'-cutoff')) then
         call getarg(i+1, arg)
         read(arg,*,iostat=ios) CutOff
         if(ios>0) stop "ERROR: Check CutOff. Use -help option for quick help"
         C=C+2
         GivenCutoff=.true.
         call getarg(i, arg)
      elseif(arg.eq.'-ccmla') then
         Method=3
         C=C+1
      elseif(arg.eq.'-verbose') then
         verbose=.true.
         C=C+1
      elseif(arg.eq.'-lowmem') then
         verbose=.true.
         C=C+1
      elseif(arg.eq.'-s1') then
         Method=4
         C=C+1
      elseif(arg.eq.'-s2') then
         Method=5
         C=C+1
      elseif(arg.eq.'-s2filt') then
         call getarg(i+1, arg)
         read(arg,*,iostat=ios) CutS2F1
         if(ios>0) stop "ERROR: Check CutS2F1. Use -help option for quick help"
         call getarg(i+2, arg)
         read(arg,*,iostat=ios) CutS2F2
         if(ios>0) stop "ERROR: Check CutS2F2. Use -help option for quick help"
         if ((CutS2F1 .lt. 0.0d0) .or. (CutS2F2  .lt. 0.d0))  &
            stop "ERROR: CutS2F1 and CutS2F2 must be positive real numbers"
         if (CutS2F1 .gt. CutS2F2)  stop "ERROR: CutS2F1 must be <= CutS2F2"
         Method=3
         s2filt=.true.
         C=C+3
         call getarg(i, arg)
      elseif(arg.eq.'-lt') then
         Lessthan=.true.
         C=C+1
      elseif(arg.eq.'-gt') then
         Lessthan=.false.
         C=C+1
      elseif(arg.eq.'-nor') then
         Reorder=.false.
         C=C+1
      elseif(arg.eq.'-e') then
         MakeCorrection=.true.
         C=C+1
      elseif(arg.eq.'-noshuffle') then
         shuffling=.false.
         C=C+1
      elseif(arg.eq.'-shuffle') then
         shuffling=.true.
         C=C+1
      elseif((arg.eq.'-d').or.(arg.eq.'-data')) then
         call getarg(i+1,arg)
         read(arg,'(A60)',iostat=ios) filedat
         if(ios.ne.0)   &
            stop "ERROR: Check the file name of data matrix. Use -help option for quick help"
         C=C+2
         call getarg(i, arg)
      elseif(arg.eq.'-prs2mat') then
         call getarg(i+1,arg)
         read(arg,*,iostat=ios) fileps2mat
         if(ios.ne.0) stop "ERROR: Check the s2mat file name. Use -help option for quick help"
         prints2=.true.
         C=C+2
         call getarg(i, arg)
      elseif(arg.eq.'-rds2mat') then
         call getarg(i+1,arg)
         read(arg,*,iostat=ios) filers2mat
         if(ios.ne.0) stop "ERROR: Check the s2mat file name. Use -help option for quick help"
         reads2=.true.
         C=C+2
         call getarg(i, arg)
      elseif((arg.eq.'-table').or.(arg.eq.'-t')) then
         call getarg(i+1,arg)
         read(arg,*,iostat=ios) filetable
         if(ios.ne.0) stop "ERROR: Check the table file name. Use -help option for quick help"
         C=C+2
         call getarg(i, arg)
      elseif((arg.eq.'-fmtDAT').or.(arg.eq.'-fmtdat')) then
         call getarg(i+1,arg)
         read(arg,*,iostat=ios) fmtDAT
         if(ios.ne.0) stop "ERROR: Check the fmtDAT specification. Use -help option for quick help"
         C=C+2
         call getarg(i, arg)
      elseif((arg.eq.'-fmtDIST').or.(arg.eq.'-fmtDIST')) then
         call getarg(i+1,arg)
         read(arg,*,iostat=ios) fmtDIST
         if(ios.ne.0) stop "ERROR: Check the fmtDIST specification. Use -help option for quick help"
         C=C+2
         call getarg(i, arg)
      elseif(arg.eq.'-usecol') then
         call getarg(i+1,arg)
         TextCol=arg
         UseCol=.true.
         C=C+2
         call getarg(i, arg)
      elseif(arg.eq.'-framestep') then
         call getarg(i+1, arg)
         read(arg,*,iostat=ios) Framestep
         C=C+2
      elseif((arg.eq.'-ns').or.(arg.eq.'-nsnap')) then
         call getarg(i+1, arg)
         read(arg,*,iostat=ios) NumSnapIni
         read(arg,*,iostat=ios) RealVar
         if((ios.ne.0).or.(NumSnapIni.lt.1).or.(NumSnapIni.ne.int(RealVar))) then
            print*,"ERROR: Check number of snapshots. Use -help option for quick help"
            stop
         else
            C=C+2
            GivenNumSnap=.true.
            call getarg(i+2, arg)
            read(arg,*,iostat=ios) NumSnap
            read(arg,*,iostat=ios) RealVar
            if((ios.ne.0).or.(NumSnap.lt.1).or.(NumSnap.ne.int(RealVar)).or.(NumSnap.lt.NumSnapIni)) then
               NumSnap=NumSnapIni
            else
               call getarg(i+3, arg)
               read(arg,*,iostat=ios) SnapInterval
               read(arg,*,iostat=ios) RealVar
               if((ios.ne.0).or.(SnapInterval.lt.1).or.(SnapInterval.ne.int(RealVar))) then
                  NumSnap=NumSnapIni
               else
                  C=C+2
               endif
            endif
         endif
         call getarg(i, arg)
      elseif((arg.eq.'-nc').or.(arg.eq.'-ncol')) then
         call getarg(i+1, arg)
         read(arg,*,iostat=ios) NumCol
         read(arg,*,iostat=ios) RealVar
         if((ios.ne.0).or.(NumCol.lt.1).or.(NumCol.ne.int(RealVar)))&
            stop "ERROR: Check number of columns. Use -help option for quick help"
         C=C+2
         GivenNumCol=.true.
         call getarg(i, arg)
      elseif(arg.eq.'-dist') then
         call getarg(i+1, arg)
         read(arg,'(A60)',iostat=ios) filedist
         if(ios.ne.0) stop "ERROR: Check the distance matrix file name. Use -help option"
         C=C+2
      elseif((arg.eq.'-help').or.(arg.eq.'-h')) then
         print*,"QUICK HELP:"
         print*,""
         print*,"SYNOPSIS:"
         print*,"      cencalc [OPTIONS] [> Output_file.out] "
         print*,""
         print*,"OPTIONS:"
         print*," -c/-cutoff CUTOFF                            Default: 8"
         print*,""
         print*," -ns SNAP_1 SNAP_2 OFFSET                     Default: Use all snapshots."
         print*,"     Entropy values are printed as a function of the number"
         print*,"     of frames from  SNAP_1 to SNAP_2 using the given OFFSET."
         print*,"     If only LAST_SNAP _1 is given then"
         print*,"     a single value is printed using frames from 1 to SNAP_1."
         print*,""
         print*," -ccmla        Use CCMLA method               Default: ccmla"
         print*,""
         print*," -s1           Use MIE First Order Method     Default: ccmla"
         print*,""
         print*," -s2           Use MIE Second Order Method    Default: ccmla"
         print*,""
         print*," -s2filt CUTS2F1 CUTS2F2                      Defaut: none "
         print*,"    Obtain S2 Corr Matrix and Select i,j Torsions: "
         print*,"    |S2(i,j)| >  CUTS2F2           ->  CCMLA "
         print*,"    CUTS2F1 > |S2(i,j)| <= CUTS2F2 ->  2nd order S2"
         print*,"    |S2(i,j)| <= CUTS2F1           ->  1st order S1"
         print*,"    If CUTS2F1=CUTS2F2 then combine only CCLMA and S1"
         print*,""
         print*," -shuffle / -noshuffle   Use shuffling procedure in S2    Default: -noshuffle "
         print*,""
         print*," -verbose      Print Verbose CCMLA output     Default: Deactivated"
         print*,""
         print*," -lowmem       Use less RAM                   Default: Deactivated"
         print*,"               Maybe useful if RAM problems are detected."
         print*,"               Reducing the number of OMP threads may also help."
         print*,""
         print*,""
         print*," -t/-table TABLE_FILE_NAME"
         print*,"               Summary of results is printed in TABLE_FILE_NAME "
         print*,""
         print*," -prs2mat S2MAT_FILE_NAME"
         print*,"               S1 and S2 corr matrix are printed in S2MAT_FILE_NAME "
         print*,""
         print*," -rds2mat S2MAT_FILE_NAME"
         print*,"               S1 and S2 corr matrix are read from  S2MAT_FILE_NAME "
         print*,""
         print*," -dist REDUCED_DISTANCE_MATRIX_FILENAME       Default: reduced_dist_matrix.dat"
         print*,""
         print*," -lt           Use Dist < Cutoff criteria     Default: lt "
         print*,""
         print*," -gt           Use Dist > Cutoff criteria     Default: lt "
         print*,""
         print*," -fmtDIST  FMT_SPECIFICATION                  Default: (F9.3) "
         print*,""
         print*," -data DATA_MATRIX_FILENAME                   Default: MATRIX.dat"
         print*,""
         print*," -fmtDAT   FMT_SPECIFICATION                  Default: (I2) "
         print*,""
         print*," -nor          Do not reorder the data        Default: Deactivated"
         print*,"               Matrix before calculations"
         print*,""
         print*," -nc NUMBER_OF_COLUMNS                        Default: Use all"
         print*,""
         print*," -usecol '1-10, 15,  20-30 '                       Default: Use all"
         print*,"         Specific columns(dihedrals) or column intervals  "
         print*,"         can be handled by cencalc. Use the notation as  shown above"
         print*,"         Only numbers and commas or hyphen can be used."
         print*,"         This option invalidates the -nc option."
         print*,""
         print*," -framestep FRAME_STEP                               Default: 1"
         print*,"         Rows in MATRIX.dat are loaded with a step  "
         print*,"         equal to FRAME_STEP                        "
         print*,""
         print*," -help         Show this quick help"
         print*,""
         print*,"EXAMPLE:"
         print*,"cencalc_ccmla -c 9 -ns 10000 100000 5000 > output"
         stop
      endif
   enddo

   if(iargc().ne.C) stop "ERROR: Check the options. Use -help option for quick help"
   if ( UseCol ) GivenNumCol=.false.

   return
END SUBROUTINE Read_Options
!-----------------------------------------------------------------------------------------

!**************************************************************
SUBROUTINE Select_Columns(NumCol,line,indx)
!**************************************************************
   use parameters
   integer NumCol
   character*1024 line,chunk
   integer indx(NumCol)
   integer i,j,k,L,ngroup,ipair,idummy,jdummy
!
   do i=1,NumCol
      indx(i)=0
   enddo
   i=1024
   do while ((line(i:i) .eq. '') .and. (i .gt. 0))
      i=i-1
   enddo
   L=i
   ngroup=0
   k=0
   do i=1,L
      if ( (line(i:i) .eq. ',') .or. ((i .eq. L) .and. (ngroup .gt. 0)) )  then
         ngroup=ngroup+1
         if ( i .eq. L ) then
            k=k+1
            chunk(k:k)=line(L:L)
         endif
         ipair=index(chunk(1:k),'-')
         if ( ipair .ne. 0) then
            chunk(ipair:ipair)=' '
            idummy=0
            jdummy=0
            read(chunk(1:k),*,err=100,end=100) idummy,jdummy
            if (( idummy .ge. 1 ) .and. ( jdummy .le. NumCol )) then
               do j=idummy,jdummy
                  indx(j)=1
               enddo
            endif
         else
            idummy=0
            read(chunk(1:k),*,err=100,end=100) idummy
            if ((idummy .ge. 1) .and. ( idummy .le. NumCol )) indx(idummy)=1
         endif
         k=0
         chunk=''
      else
         k=k+1
         chunk(k:k)=line(i:i)
      endif
   enddo
   if (  ngroup  .eq. 0 ) then
      print*,'preprocessed line',line(1:L)
      ipair=index(line(1:L),'-')
      line(ipair:ipair)=' '
      if ( ipair .ne. 0) then
         read(line(1:L),*,err=100,end=100) idummy,jdummy
         do j=idummy,jdummy
            indx(j)=1
         enddo
      else
         read(line(1:L),*,err=100,end=100) idummy
         indx(idummy)=1
      endif
   endif
   return
100 continue
   write(6,'(''Error while reading selected columns in '',A40)')  chunk(1:k)
   stop
END SUBROUTINE Select_Columns
!

!**************************************************************
SUBROUTINE Randomize_Row(RandRow,NumSnap)
!**************************************************************
   integer NumSnap,i,j,temp
   integer RandRow(NumSnap)
   real rand

   do i=1,NumSnap
      call random_number(rand)
      j=ceiling(rand*(NumSnap-i+1) +  (i-1) )
      temp=RandRow(i)
      RandRow(i)=RandRow(j)
      RandRow(j)=temp
   enddo

END SUBROUTINE Randomize_Row

!**************************************************************
SUBROUTINE TICK_TIME(TimeLabel)
!**************************************************************
   use parameters
   real CpuTime0,CpuTime1,CpuTime2,Delta_Time,Delta_CPU
   integer(K4C) RT0,RT1,RT2,rate
   integer i,j,l
   character*(*) TimeLabel
   logical :: first=.true.
   save CpuTime0,RT0,CpuTime1,RT1,rate,first

   if ( first) then
      call system_clock(count=RT0, count_rate=rate)
      call cpu_time(CpuTime0)
      call system_clock(count=RT1)
      call cpu_time(CpuTime1)
      first=.false.
      return
   endif

   call cpu_time(CpuTime2)
   call system_clock(count=RT2)

   if ( index('Total',TimeLabel) .ne. 0)  then
      Delta_Time=real(RT2-RT0)/real(rate)
      Delta_CPU=CpuTime2-CpuTime0
   else
      Delta_Time=real(RT2-RT1)/real(rate)
      Delta_CPU=CpuTime2-CpuTime1
   endif

   write(*,'('' CPU Time: '',A30,F11.2,A8,F9.2,A6)') TimeLabel,Delta_CPU," seconds",((Delta_CPU)/3600.)," hours"
   write(*,'('' REAL Time: '',A30,F11.2,A8,F9.2,A6)') TimeLabel,Delta_Time," seconds",(Delta_Time/3600.)," hours"

   CpuTime1=CpuTime2
   RT1=RT2
   return
END SUBROUTINE TICK_TIME

